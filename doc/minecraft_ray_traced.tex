%\documentclass[]{scrartcl}
\documentclass[]{article}
% sans-serif font
\renewcommand{\familydefault}{\sfdefault}

% Bibtex citations
%\usepackage{cite}
% sequence diagrams
\usepackage{pgf-umlsd}
% one inch margins
\usepackage[a4paper, margin=1in]{geometry}
% url referencing
\usepackage{url}
% show reference and figure lists in table of contents
\usepackage[nottoc,numbib]{tocbibind}
% add number to list of figures in table of contents
\renewcommand{\listoffigures}{\begingroup
\tocsection
\tocfile{\listfigurename}{lof}
\endgroup}

\usepackage{tikz,tkz-euclide}
\usepackage{tikz-qtree}
% tikz features
\usetikzlibrary{decorations.pathreplacing,angles,quotes,shapes,arrows,fit}
\usetikzlibrary{calc} % coordinates
\usetikzlibrary{arrows.meta} % better arrows
\usetikzlibrary{trees} % this is to allow the fork right path
\usetkzobj{all}

% real numbers symbol
\usepackage{amssymb}

\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  %keywordstyle=\color{blue},
  %commentstyle=\color{olive},
}

% set default arrow
\tikzset{>=Latex}

% define arrow style
\tikzstyle{arw}=[-{Latex[length=3mm]}]

% extra math
\usepackage{mathtools}
% icons!
\usepackage{fontawesome}
% quotations
\usepackage{csquotes}

% bigger dot for multiplication
\makeatletter
\newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother

\title{Minecraft: Ray Traced}
%\subtitle{Or: A dynamic acceleration structure for voxel worlds}
\author{Marco Jonkers}

\begin{document}

%\maketitle

\begin{titlepage}
  \centering
  \includegraphics[scale=0.5]{eng_logofc_uas.jpg}\par\vspace{1cm}
  {\scshape\LARGE NHTV Breda University of Applied Sciences\par}
  \vspace{1cm}
  {\scshape\Large Personal project\par}
  \vspace{1.5cm}
  {\huge\bfseries Minecraft: Ray Traced\par}
  \vspace{2cm}
  {\Large Marco Jonkers\par}
  \vspace{0.5cm}
  {Supervisor: David H{\"o}rchner\par}

  
  \vspace{2cm}
  
  \begin{abstract}
    This project attempts to implement a GPU ray tracer in Minecraft.
    The ray tracing itself is done in CUDA.
    First, we attempt to ray trace the Minecraft OpenGL vertex buffers directly.
    Then, we implement our own data structures for increased performance.
  \end{abstract}
  
  \vfill
  
  % Bottom of the page
  {\large \today\par}
\end{titlepage}

% TODO: Do I want to keep the list of figures?

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage

\section{Introduction}
Minecraft is a 2011 first-person sandbox video game.
Originally created by Markus \enquote{Notch} Persson, it is currently maintained by Mojang.

Minecraft comes in multiple editions, for various platforms. This paper focuses on PC version 1.10.2, released for Windows, macOS, and Linux.
The PC version is written in Java.

In Minecraft, the game world consists of a three-dimensional grid.
The world is procedurally generated, and mostly comprised of unit sized blocks, as shown in Figure \ref{fig:ss-worldgen}.

\begin{figure}
  \includegraphics[width=\textwidth]{ss-worldgen.png}
  \centering
  \caption{In-game screenshot of Minecraft, without heads-up display (HUD) or viewmodel.}
  \label{fig:ss-worldgen}
\end{figure}

\section{Minecraft Renderer}
Due to memory constraints, Minecraft divides the world up in chunks.
These are 16$\times$256$\times$16 columns of blocks.
As the player moves, the chunks that are closer to the player are loaded, while those further away are unloaded.
The first time a chunk is loaded in a save file, it needs to be generated.
Chunks are generated in a multi-threaded system.

For rendering, Minecraft uses OpenGL.
There exist two graphics options in the video settings:
\begin{description}
  \item[Display Lists] An OpenGL 1.0 core function.
    Display Lists are grouped commands which have been compiled and sent to the GPU.
    An object can be drawn by calling a list.
    This list can be reused, which means we do not have to send the data over again.
  \item[Vertex Buffer Objects] Vertex Buffer Objects (\enquote{VBOs}) were available in OpenGL 1.4 through an extension, and were later added to the core specification in version 2.1.
    This feature allows us to have a buffer with vertex information, and telling the driver where and how the attributes are stored in the buffer.
\end{description}
Our project makes use of Minecraft's VBO rendering, because this lets us extract the vertex data from the buffers.

\subsection{RenderChunks}
A RenderChunk is a group of 16$\times$16$\times$16 blocks (see Figure \ref{fig:renderchunk}).
Every chunk in the world is comprised of 16 RenderChunks.
When a block is added or removed, the corresponding RenderChunks are re-meshed and re-uploaded to the GPU.
The size of the RenderChunk results in small GPU buffer updates.
As a downside, this means that Minecraft must manage a significant amount of small vertex buffers.
The renderer uses frustum culling to remove most RenderChunks from the draw queue.

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.3]
  \foreach \x in{0,...,16} {
    \draw[very thin] (0,\x ,16) -- (16,\x ,16);
    \draw[very thin] (\x ,0,16) -- (\x ,16,16);
    \draw[very thin] (16,\x ,16) -- (16,\x ,0);
    \draw[very thin] (\x ,16,16) -- (\x ,16,0);
    \draw[very thin] (16,0,\x ) -- (16,16,\x );
    \draw[very thin] (0,16,\x ) -- (16,16,\x );
  }
  % right
  \draw[dashed] (16,0,0) -- ++(5,0,0);
  \draw[dashed] (16,16,0) -- ++(5,0,0);
  \draw[dashed] (16,16,16) -- ++(5,0,0);
  \draw[dashed] (16,0,16) -- ++(5,0,0);
  % top
  \draw[dashed] (0,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,16) -- ++(0,5,0);
  \draw[dashed] (0,16,16) -- ++(0,5,0);
  % back
  \draw[dashed] (0,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,0,0) -- ++(0,0,-5);
  % front
  \draw[dashed] (0,16,16) -- ++(0,0,5);
  \draw[dashed] (16,16,16) -- ++(0,0,5);
  \draw[dashed] (16,0,16) -- ++(0,0,5);
  \draw[dashed] (0,0,16) -- ++(0,0,5);
  % left
  \draw[dashed] (0,0,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,0) -- ++(-5,0,0);
  % bottom
  \draw[dashed] (16,0,0) -- ++(0,-5,0);
  \draw[dashed] (16,0,16) -- ++(0,-5,0);
  \draw[dashed] (0,0,16) -- ++(0,-5,0);
  % curly braces
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[left=15pt]{16} (0,16,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[below=15pt]{16} (16,0,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (16,0,16) -- node[below=15pt,right=10pt]{16} (16,0,0);
  \end{tikzpicture}
  \caption[Diagram of a RenderChunk]{A single, completely filled RenderChunk.}
  \label{fig:renderchunk}
\end{figure}

There are four render layers, based on texture properties (Figure \ref{fig:ss-layers}).
\begin{description}
  \item[Solid] Uses textures that are fully opaque. Most world blocks are in this group.
  \item[Cutout] Uses textures that have transparent texels.
  \item[Mipped Cutout] Identical to Cutout, but mipmapped.
  \item[Translucent] Used for block which have partial transparency (alpha blending).
\end{description}

The render layers exist such that Minecraft can do transparency sorting and batching.
Note: Our ray tracer has no use for this functionality.
A RenderChunk has one vertex buffer for every layer.
This results in further fragmentation of the vertex data.
However, not all vertex buffers are always in use.

The vertex data from the world geometry contains four attributes (see Table \ref{tbl:vertex}).

\begin{table}
  \centering
  \begin{tabular}{|l|r|r|r|} \hline
    Attribute & Type & \# & Bytes\\ \hline
    Position & float & 3 & 12 \\ \hline
    Color & byte & 4 & 4 \\ \hline
    Lightmap & float & 2 & 8 \\ \hline
    Texture & short & 2 & 4 \\ \hline \hline
    \multicolumn{3}{|l|}{Total} & 28 \\ \hline
  \end{tabular}
  \caption{Vertex attributes.}
  \label{tbl:vertex}
\end{table}

\begin{figure}
  \includegraphics[width=\textwidth]{ss-layers.png}
  \centering
  \caption[One object from each render layer]{One object from each render layer. From left to right: Cobblestone (Solid), Glass (Cutout), Hopper (Cutout Mipped), and Stained Glass (Translucent).}
  \label{fig:ss-layers}
\end{figure}

% TODO: Big disclaimer that source code names all come from MCP, not Mojang
\section{Minecraft Forge}
Minecraft Forge (\enquote{Forge}) is a community created platform for developing and using modifications ("mods") for Minecraft.\footnote{Modification of Minecraft ("modding") is not officially supported by Mojang. For more information, visit \url{https://account.mojang.com/terms}}
It was released around November 2011.
\subsection{Setting up a mod development environment}
The Mod Development Kit can be freely downloaded from the Forge website\footnote{\url{http://files.minecraftforge.net/}}.
It includes scripts which set up a development environment for the creation of mods.
Forge explicitly supports IntelliJ IDEA as development environment, which is what we will use.
The Forge scripts download, decompile, and deobfuscate the Minecraft binaries.
The deobfuscation is done with the help of the Mod Coder Pack\footnote{\url{http://www.modcoderpack.com/website/}}, a community effort which provides useful names to the source code.


%The path to our DLLs is passed to the virtual machine.
%During development, Java loads our classpath directly.
%In release mode, our class files would have to be compressed into an archive first.

\subsection{Changes to Minecraft source code}
Aside from gaining access to Minecraft's source code, Forge inserts some code to make mod creation easier, and to provide mod compatibility.
One of the major features is the event system.
A class method can subscribe to an event, which causes the method to be called when the event is fired.
There are events for a multitude of gameplay features.
Another feature is the Ore Dictionary, which provides a compatibility layer for blocks between mods which share the same functionality.

\subsection{Creating a mod}
In general there are three approaches to creating a mod:
\begin{enumerate}
  \item Build a mod on top of the Forge Minecraft code
  \item Edit the Minecraft source directly
  \item Use class transformers during mod loading
\end{enumerate}
For most mods, the first approach is sufficient.
This also enables the developer to freely distribute their mod.
Editing the Minecraft source directly means that the mod cannot be redistributed, because the original Minecraft code is copyrighted.
The Forge development environment prevents the user from editing Minecraft source files directly.
The third approach should be used as a last resort.
Class transformers allow a mod to change the bytecode of a vanilla Minecraft class at runtime.
Mods which have class transformers are called \enquote{coremods}.
This functionality holds a lot of power, but can cause compatibility issues with other coremods.

\section{Hardware}
This project is developed on the following machines:

\begin{center}
  \begin{tabular}{| l || c | c |} \hline
    & Dell XPS 15 L502X & Desktop \\ \hline
    Operating System & \multicolumn{2}{c|}{Microsoft Windows 10 Pro 64-bit} \\ \hline
    Processor & Intel Core i7-2630QM & Intel Core i7-4790 \\ \hline
    Memory & 4 GB DDR3 & 8 GB DDR3 \\ \hline \hline
    GPU & NVIDIA GeForce GT 540M & NVIDIA GeForce GTX 970\\ \hline
    - CUDA Cores & 96 & 1664 \\ \hline
    - Shader Multiprocessors & 2 & 13 \\ \hline
    - Compute Capability & 2.1 & 5.2 \\ \hline
    %- Processor Clock & 1344 MHz &  \\ \hline
    - Memory Clock & 900 MHz & 7010 MHz \\ \hline
    - Graphics Clock & 672 MHz & 1140 MHz \\ \hline
    - Memory & 2 GB & 4 GB \\ \hline % \footnote{\url{https://blogs.nvidia.com/blog/2015/02/24/gtx-970/}}
  \end{tabular}
\end{center}

Additionally, we leave the Minecraft window at the default resolution of 854x480 pixels, which equals 409920 rays (assuming one ray per pixel).

% TODO: This part sucks
\section{C++ and CUDA}
%We want to create a GPU ray tracer.
%There are various methods to achieve this. 
%We want to take advantage of the vertex buffers in CUDA.
%Because Minecraft uses OpenGL through the LWJGL\footnote{\url{https://www.lwjgl.org/}} library, we could have chosen to use OpenGL compute shaders.
%However, we have no experience with OpenGL compute shaders, whereas we do have experience with NVIDIA CUDA.

%There exist Java bindings for CUDA, but using C++ removes our dependency on a binding layer.
\subsection{Java Native Interface}
Java Native Interface (\enquote{JNI}) is a programming framework that allows for Java code to interact with native code.
\subsubsection{javah}
\texttt{javah} is a tool that generates C header and source files for Java classes that declare native methods.
We use the generated header file in our Visual Studio project.
The header file is compatible with C++ code bases as it includes an \texttt{\#ifdef \_\_cplusplus} directive which prepends an \texttt{extern \char`\"C"} to the function declarations.
\cite{noauthor_jni_nodate} Function parameters are passed as the following:
% TODO: citation

\begin{center}
\begin{tabular}{|l|l|l|} \hline
  Java & C++ & represented type \\ \hline
  boolean & jboolean & unsigned 8 bits \\ 
  byte & jbyte & signed 8 bits \\ 
  char & jchar & unsigned 16 bits \\ 
  short & jshort & signed 16 bits \\ 
  int & jint & signed 32 bits \\ 
  long & jlong & signed 64 bits \\ 
  float & jfloat & 32 bits \\ 
  double & jdouble & 64 bits \\ 
  void & void & not applicable \\ \hline
\end{tabular}
\end{center}

Additionally, Java objects are passed as (subclasses of) \texttt{jobject} instances, as can be seen in Figure \ref{fig:jobject}.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[level distance=1.25in,,scale=.75]
    \tikzset{edge from parent/.style= 
      {thick, draw,
        edge from parent fork right},every tree node/.style={draw,minimum width=1in,text width=1in, align=center},grow'=right}
    \Tree 
    [.\texttt{jobject}
    [.\texttt{jclass} ]
    [.\texttt{jstring} ]
    [.\texttt{jthrowable} ]
    [.\texttt{jarray}
    [.\texttt{jobjectArray} ]
    [.\texttt{jbooleanArray} ]
    [.\texttt{jbyteArray} ]
    [.\texttt{jcharArray} ]
    [.\texttt{jshortArray} ]
    [.\texttt{jintArray} ]
    [.\texttt{jlongArray} ]
    [.\texttt{jfloatArray} ]
    [.\texttt{jdoubleArray} ]
    ]
    ]
    \end{tikzpicture}
  \end{center}
\caption{C++ inheritance diagram}
\label{fig:jobject}
\end{figure}

\subsection{CUDA}
CUDA is a parallel computing platform and programming model developed by NVIDIA.
It is only compatible with NVIDIA hardware.
We will be using the CUDA Runtime API (as opposed to the CUDA Driver API), as it is the easier of the two to use.
\subsection{CUDA/OpenGL interoperability}
CUDA provides an API for operating on OpenGL primitives.
More specifically, it is able to map an OpenGL vertex buffer to a CUDA device pointer, allowing a CUDA kernel to access the contents of the buffer.
We can also copy the contents of a CUDA buffer to an OpenGL texture.

Our strategy for ray tracing will be as follows:
\begin{enumerate}
  \item Upload world data to CUDA
  \item Run the ray tracing kernel
  \item Map an OpenGL texture to a CUDA array
  \item Copy the kernel output buffer to the CUDA array
  \item Pass the OpenGL texture to Minecraft
\end{enumerate}

\subsection{Creating a Visual Studio project}
For setting up the native part of the mod, we create a Visual Studio CUDA project.
NVIDIA has a CUDA plugin for Visual Studio called Nsight.
This sets up Visual Studio so we can write CUDA kernels.

\tikzstyle{dll}=[draw,rectangle,text width=2cm,text centered,node distance=3.5cm]
\tikzstyle{java}=[draw,rectangle,inner sep=0.3cm,rounded corners,node distance=3.5cm,minimum width=8em,minimum height=4em]
\begin{figure}
  \begin{tikzpicture}[auto]
  % loader.dll
  \node[dll] (loader_dll) {loader.dll};
  % raytracer.dll
  \node[dll,right of=loader_dll] (raytracer_dll) {raytracer.dll};
  % Raytracer.class
  \node[java,fit=(loader_dll)] (container) {};
  % Raytracer.class label
  \node at (container.north)[above](raytracer){Raytracer.class};
  % mcraytracer.jar
  \node[java,fit=(container)(raytracer)](minecraft){};
  % mcraytracer.jar label
  \node at (minecraft.north)[above](jar){mcraytracer.jar};
  % minecraft jar
  \node[java,left of=raytracer](minecraft_jar){minecraft.jar};
  % Forge Minecraft
  \node[java,below of=minecraft_jar](forge_minecraft){Forge Minecraft};
  \node[java,right of=forge_minecraft](external_libraries){External libraries};
  % Java Virtual Machine
  \node[java,fit=(jar)(minecraft)(minecraft_jar)(forge_minecraft)(external_libraries)](java){};
  % Java Virtual Machine label
  \node at (java.north)[above](vm_label){Java Virtual Machine};
  
  \draw [->] (loader_dll) -- node {} (raytracer_dll);
  %\draw [<->] (minecraft_jar) -- node {} (minecraft);
  \end{tikzpicture}
  \centering
  \caption[Binary interaction]{Interaction diagram of the different binaries.}
  \label{fig:modules}
\end{figure}

\subsubsection{Reloading C++}
Java IDEs such as IntelliJ support hot-swapping of method bodies by using the HotSwap functionality of the Java Platform Debugger Architecture.
We created something similar for our native code by using a technique called DLL reloading.
Once a native library has been loaded by the JVM, we cannot make changes to it.
Therefore we are using a passthrough DLL, which passes the calls from Java to another DLL.
We have shown this in Figure \ref{fig:modules}.

\subsubsection{Setting up the Visual Studio debugger}
IntelliJ debug sessions are good for testing if our Java ASM works correctly, and if our JNI bindings are set up properly.
However, if an error occurs a native part, the debug session ends immediately.
The crash output from IntelliJ is unable to use the debug information from Visual Studio.
We use the Visual Studio debugger for the native part.
We launch java.exe with the right command line arguments and working directory.
We looked at the launch parameters given to java.exe when starting a debug session from IntelliJ.
The Visual Studio debugger can be configured to launch Minecraft by copying the command line arguments from an IntelliJ debug session.
The JVM uses the access violation signal internally for its memory exception handling.
When an access violation is thrown from the JVM, this can be safely ignored.
However, Visual Studio can easily block hundreds of these signals.
Visual Studio 2017 offers an option to ignore certain exceptions per module, allowing me to break on access violations in our own native code while ignoring those coming from the JVM.

\subsection{Kernel overhead on Windows}
There is a non-trivial amount of overhead attached to the launch of a CUDA kernel on Windows.
This is due to the Windows Display Driver Model (\enquote{WDDM}).
An alternative would be to use the Tesla Compute Cluster driver (\enquote{TCC}).
Unfortunately, TCC is not available for GeForce GPUs.
Additionally, GPUs in TCC cannot be connected to a display.
The measured overhead per kernel launch on both machines is roughly half a millisecond, which is not negligible.
Therefore, we avoid executing multiple kernels per frame.

\section{Ray Tracing OpenGL Vertex Buffers}
Our initial idea is to ray trace the uploaded VBOs from Minecraft directly.

\subsection{Forge Events}
%I wanted to see if I could make my mod work using the first approach.
%Forge adds hooks to the game loop which I could use to intercept the rendering code.
The \texttt{Raytracer} class listens to the following events:
\begin{itemize}
  \item \texttt{FMLInitializationEvent} \\
    As the name indicates, this event is fired when Forge is initializing Minecraft.
    This event is used to initialize the mod.
    Here we also obtain a reference to the \texttt{Minecraft} singleton class.
    The mod needs to be registered in the \texttt{ClientRegistry} in order to receive further Forge events.
  \item \texttt{TickEvent.ClientTickEvent} \\
    This event is fired 20 times per second, and can be regarded as the client-sided update function.
    We listen to this event to check for keyboard input changes.
  \item \texttt{GuiScreenEvent.InitGuiEvent.Pre} \\
    This is the first event that is fired when a window resize is detected.
    The event does not contain any resize information, so we track it manually.
    The resolution information in the \texttt{Minecraft} class is public, so we extract it from there.
    The information is passed to C++, such that the CUDA and OpenGL resources can be resized if they need to be.
    OpenGL supports resizing by calling \texttt{glTexImage2D} with the new information, without having to call \texttt{glGenTextures} again.
    In CUDA, it is required to unregister and re-register the associated graphics resource.
    The kernel output buffer is also resized. This uses a pair of \texttt{cudaFree} and \texttt{cudaMalloc} calls.

    % TODO: something about OpenGL textures and power of two?
  \item \texttt{TickEvent.RenderTickEvent} \\
    This event is fired when Minecraft starts rendering the next frame.
    
    In order to prevent Minecraft from drawing the world after we have done the ray tracing, we copy the \texttt{WorldClient} reference from \texttt{Minecraft}, and set the value in \texttt{Minecraft} to \texttt{null}.
    This effectively causes Minecraft to skip the rendering of the game world, because it has an internal check for the \texttt{WorldClient} there.
    If it is \texttt{null}, nothing is rendered.
    However, this also disables rendering of the game overlay, which contains elements like the player inventory and menu's.
    We manually draw the game overlay after drawing the ray tracing result to the screen.
  \item \texttt{GuiScreenEvent.DrawScreenEvent.Pre} \& \texttt{GuiScreenEvent.DrawScreenEvent.Post} \\
    We noticed that the background of the game overlay was solid instead of transparent.
    This is due to another check for the \texttt{WorldClient} instance during drawing.
    Because we previously made it \texttt{null}, we now have to restore it on the \texttt{GuiScreenEvent.DrawScreenEvent.Pre} event in order to draw the background.
    We set it back to null at the \texttt{GuiScreenEvent.DrawScreenEvent.Post} event.
  %\item \texttt{GuiOpenEvent} \\
    %Fired when the top-level menu changes.
\end{itemize}
We were able to draw a full-screen texture using CUDA and copy it to Minecraft using OpenGL.
However, we are not able to obtain the Minecraft vertex buffers using Forge Events alone.
That is where we either need to change the Minecraft source directly, or use Java ASM.
We chose the second option.

% TODO: Did I already define what ASM is somewhere?
% TODO: This part assumes deobfuscated source code; make sure that's mentioned
\subsection{Using ASM}
Forge provides the \texttt{IFMLLoadingPlugin} interface for mods which have customized loading procedures.
It provides a method for adding class transformers, which can edit the Minecraft bytecode before it is loaded into the game.
An example of bytecode can be found in Figure \ref{fig:bytecode}.
We create a class transformer by implementing Forge's \texttt{IClassTransformer} interface, which contains a single method: \texttt{transform}.
Every time a Minecraft class is initialized, the method is called with its name and bytecode.
This is the general procedure if we want to change a method:

\begin{enumerate}
  \item Check the name of the class
  \item Parse the bytecode of the class to a \texttt{ClassNode}
  \item Find the method in the \texttt{MethodNode} list of the \texttt{ClassNode}
  \item Find the instruction in the \texttt{InsnList} list of the \texttt{MethodNode}
  \item Insert new instructions
  \item Remove old instructions
  \item Return the modified class as a byte array
\end{enumerate}

% TODO: Finish this sentence
%To minimize the amount of ASM changes, it is recommended to 
We changed the following classes:

\begin{itemize}
  \item \texttt{EntityRenderer} \\
    Contains the method \texttt{updateCameraAndRender} that calls \texttt{renderWorld} to render the world.
    We replace it with a call to a \texttt{Raytracer} method.
    An easy way to do this is by having a Singleton.
    This removes the need to introduce a new field in the modified class.
    It involves adding two instructions:
    \begin{itemize}
      \item \texttt{INVOKESTATIC} to put the Singleton on the stack
      \item \texttt{INVOKEVIRTUAL} to call the static function
    \end{itemize}
  \item \texttt{RenderGlobal} \\
    Contains a \texttt{ChunkRenderContainer} field that is initialized using a \texttt{VboRenderList}.
    It is a list of RenderChunks which is rebuilt every frame.
    We replace the construction of the \texttt{ChunkRenderContainer} by modifying the \texttt{NEW} and \texttt{INVOKESPECIAL} instructions to use our \texttt{RaytracerRenderList} instead.
    \texttt{RaytracerRenderList} overrides \texttt{ChunkRenderContainer} such that the list of \texttt{VertexBuffer}s is sent to C++ instead of being drawn using OpenGL.
\end{itemize}
The sequence diagram can be found in Figure \ref{fig:sequence}.

% TODO: the basic concepts of render layers should be known at this point

\lstdefinelanguage{bytecode} % Unused
{
  % list of keywords
  morekeywords={
    ALOAD,
    INVOKESPECIAL,
    PUTFIELD,
    INVOKESTATIC,
    RETURN,
    LOCALVARIABLE,
  },
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{//}, % l is for line comment
  %morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  %morestring=[b]" % defines that strings are enclosed in double quotes
}
\begin{figure}
\begin{lstlisting}[breaklines,frame=single]
// Java
public Renderer(Raytracer raytracer) {
    this.raytracer = raytracer;
    this.mc = Minecraft.getMinecraft();
}

// Bytecode
public <init>(Lcom/marcojonkers/mcraytracer/Raytracer;)V
ALOAD 0
INVOKESPECIAL java/lang/Object.<init> ()V
ALOAD 0
ALOAD 1
PUTFIELD com/marcojonkers/mcraytracer/Renderer.raytracer : Lcom/marcojonkers/mcraytracer/Raytracer;
ALOAD 0
INVOKESTATIC net/minecraft/client/Minecraft.getMinecraft ()Lnet/minecraft/client/Minecraft;
PUTFIELD com/marcojonkers/mcraytracer/Renderer.mc : Lnet/minecraft/client/Minecraft;
RETURN
LOCALVARIABLE this Lcom/marcojonkers/mcraytracer/Renderer; 0
LOCALVARIABLE raytracer Lcom/marcojonkers/mcraytracer/Raytracer; 1
\end{lstlisting}
\caption[Example bytecode]{Example bytecode for the constructor of our \texttt{Renderer} class. Note the use of Java VM signatures. \texttt{ALOAD} puts a \texttt{LOCALVARIABLE} (listed at the bottom) on the stack. Method parameters and \texttt{this} are implicit local variables.}
\label{fig:bytecode}
\end{figure}

% Code flow structure
\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{minecraft}{Forge Minecraft}{}
    \newinst[2]{forge}{Forge Mod}{}
    \newinst[2]{loader}{C++/CUDA}{}
    \begin{call}{minecraft}{transform()}{forge}{}
    \end{call}
    \postlevel
    \begin{call}{minecraft}{Raytracer()}{forge}{}
      \begin{call}{forge}{init()}{loader}{}
      \end{call}
    \end{call}
    %    \postlevel
    %    \begin{call}{minecraft}{onPreInitGuiEvent()}{forge}{}
    %      \begin{call}{forge}{resize()}{loader}{}
    %      \end{call}
    %    \end{call}
    \begin{sdblock}{Main Loop}{}
      \begin{call}{minecraft}{initialize()}{forge}{}
        \begin{call}{forge}{setViewEntity()}{loader}{}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{addRenderChunk()}{forge}{}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderChunkLayer()}{forge}{}
        \begin{call}{forge}{setVertexBuffer()}{loader}{}
          \begin{call}{loader}{GetIntField()}{loader}{glBufferId}
          \end{call}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderWorld()}{forge}{}
        \begin{call}{forge}{setViewingPlane()}{loader}{}
        \end{call}
        \postlevel
        \begin{call}{forge}{raytrace()}{loader}{texture ID}
          \begin{call}{loader}{Kernel()}{loader}{}
          \end{call}
        \end{call}
      \end{call}
    \end{sdblock}
  \end{sequencediagram}
  \caption[Sequence diagram]{Sequence diagram showing interaction between the modules}
  \label{fig:sequence}
\end{figure}

\subsection{Camera construction}
We unproject the corners of the screen to world space by applying the inverse view-projection matrix from the game.
These coordinates, along with the player position and the vertical field of view ("FoV") from the game settings are passed to C++.
With this information, we can calculate the ray origin and view pyramid, as shown in Figure \ref{fig:rayorigin}.

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.5]
  \coordinate (A) at (0,0,0);
  \coordinate (B) at (0,0,16);
  \coordinate (C) at (0,9,0);
  \coordinate (D) at (0,9,16);
  \coordinate (E) at (0,4.5,8);
  \coordinate (F) at (-8,4.5,8);
  \coordinate (G) at (0,4.5,0);
  \coordinate (H) at (0,9,8);
  \coordinate (I) at (-5,0,0);
  \draw[arw] (A) node[anchor=north]{$P$} -- (B) node[anchor=north]{$Q$};
  \draw[arw] (A) -- (C) node[anchor=south]{$R$};
  \draw[dotted] (H) -- (E);
  \draw[dashed] (B) -- (D);
  \draw[dashed] (C) -- (D);
  \tkzMarkRightAngle[draw=black,size=0.5](H,E,F)
  \tkzMarkRightAngle[draw=black,size=0.5](C,A,I)
  \tkzMarkRightAngle[draw=black,size=0.5](C,G,E)
  \tkzMarkSegment[pos=.75,mark=|](A,C)
  \tkzMarkSegment[pos=.25,mark=|](A,C)
  
  % eye point stuff
  \draw[dotted] (E) node[anchor=north west]{$S$} -- (F) node[anchor=east]{\faVideoCamera};
  \draw[arw] (A) -- node[anchor=north west]{$\vec{u}$} (I);
  \draw[dotted] (H) -- (F);
  \draw[dotted] (G) -- (E);
  \pic [draw, -, "$\theta$", angle eccentricity=1.5] {angle = E--F--H};
  \end{tikzpicture}
  
  \begin{align}
  \theta& = \frac{vertical\ field\ of\ view}{2} \nonumber \\
  \vec{u}& = \overrightarrow{PQ}\times\overrightarrow{PR} \nonumber \\
  S& = \frac{Q + R}{2} \nonumber \\
  \text{\faVideoCamera}_{pos}& = S + Normalize(\vec{u}) \bigcdot\frac{\lvert\lvert\overrightarrow{PR}\rvert\rvert}{2 \tan\left(\theta\right)} \nonumber
  \end{align}
  \caption{Ray origin calculations}
  \label{fig:rayorigin}
\end{figure}

\subsection{C++}
In C++, we use JNI calls to obtain the OpenGL buffer ID and index count of the \texttt{VertexBuffer}, as the fields are marked \texttt{private} in Java.
Empty buffers are discarded.
We register the buffer in CUDA to obtain a \texttt{cudaGraphicsResource}.
Each buffer must be registered exactly once.
We store the \texttt{cudaGraphicsResource} handles in a three-dimensional array (see Figure \ref{fig:grid}).
The size of the array is defined by the render distance option in the game settings.
The render distance is defined in chunks (minimum = 2, maximum = 16 on 32-bit Java, 32 on 64-bit Java).

The grid is indexed $x,z,y$.
The handles are placed in the grid such that the player chunk is in the center of the $x$\nobreakdash--$z$~plane:
\begin{align}
  x_{grid} &= \left\lfloor\frac{x_{player}}{16}\right\rfloor - \frac{x_{chunk}}{16} + \texttt{MAX\_RENDER\_DISTANCE} \nonumber \\
  y_{grid} &= \left\lfloor\frac{y_{player}}{16}\right\rfloor \nonumber \\
  z_{grid} &= \left\lfloor\frac{z_{player}}{16}\right\rfloor - \frac{z_{chunk}}{16} + \texttt{MAX\_RENDER\_DISTANCE} \nonumber
\end{align}

When the player moves to a new chunk, we shift the grid along the $x$\nobreakdash--$z$~plane.
This allows us to keep the vertical \texttt{RenderChunk}s contiguous in memory.

\begin{figure}
  \centering
  \begin{tikzpicture}
  \draw[step=0.5cm,very thin,opacity=0.2] (-6,-6) grid (6.5,6.5);
  %\fill (0,0) -- (0.5,0) -- (0.5,0.5) -- (0,0.5) -- (0,0);
  \draw[dashed] (-6,0) -- (6.5,0);
  \draw[dashed] (-6,0.5) -- (6.5,0.5);
  \draw[dashed] (0,-6) -- (0,6.5);
  \draw[dashed] (0.5,-6) -- (0.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0.5,0.5) -- node[above=15pt] {12} (6.5,0.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0.5) -- node[left=15pt] {12} (0,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,6.5) -- node[above=15pt] {35} (6.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,-6) -- node[left=15pt] {35} (-6,6.5);
  \draw[fill] (0.25,0.25) circle (.5ex);
  
  % view frustum
  \draw (0.25,0.25) -- (-6,5.25);
  \draw (0.25,0.25) -- (6.5,5.25);
  \fill[color=gray,opacity=0.3] (-6,6.5) -- (-6,5.25) -- (0.25,0.25) -- (6.5,5.25) -- (6.5,6.5);
  
  %\draw[decoration={brace,mirror,raise=5pt},decorate] (0.5,0) -- node[below=6pt] {Render distance} (6.5,0);
  \end{tikzpicture}
  \caption[Top-down view of vertex buffer array]{
    A top-down view of the vertex buffer array, assuming a render distance of 12.
    The player's view cone is shown facing north.
    Each cell contains 16 \texttt{RenderChunk}s.
    When the player crosses a horizontal chunk boundary, every buffer in the grid is moved once space.
  }
  \label{fig:grid}
\end{figure}

After all \texttt{RenderChunk}s have been passed to C++ for the current frame, we obtain a device pointer for every \texttt{cudaGraphicsResource}.
These point to vertex data on the GPU and can be used in a CUDA kernel.
We use \texttt{cudaMemcpy} to copy the device pointers and array sizes from host to device memory.
Before we send the player position to the kernel, we transform it to chunk space:
\begin{equation}
f(x) = \frac{x}{16} - \left\lfloor\frac{x}{16}\right\rfloor
\end{equation}
This maps the player's position to $[0, 1)$, which is suitable for grid traversal.

% TODO: Explain thread groups before this
\subsection{CUDA}
We define the CUDA block size to be 8x8 threads.
Every pixel (assuming Minecraft's default resolution of 854x480) will run the kernel to fire a ray.
The implicit CUDA variables \texttt{blockIdx} and \texttt{threadIdx} are used in the kernel to calculate which pixel is being processed.
We calculate the ray direction for every pixel by linearly interpolating the corners of the viewport (refer to Figure \ref{fig:rayorigin}):

\begin{equation}
  Lerp(a, b, t) = a + t \bigcdot (b-a)
\end{equation}

\begin{equation}
  Normalize(\vec{v}) = \frac{\vec{v}}{\lvert\lvert\vec{v}\rvert\rvert}
\end{equation}

\begin{displaymath}
  dir_{ray} = Normalize(Lerp(P, Q, u) + Lerp(P, R) - P - pos_{camera})
\end{displaymath}

We use this in a 3D voxel traversal algorithm from \cite{amanatides1987fast}.
Amanatides et al. do not explain how to obtain the value of $t$ at which a ray crosses the first voxel boundary.
We have put the method in equation \ref{eq:findfirstt}.

\begin{equation}
f(x, dx) =
\begin{cases}
\frac{\lceil x \rceil - x}{\lvert dx \rvert} & dx > 0 \\
\frac{x - \lfloor x \rfloor}{\lvert dx \rvert} & dx < 0 \\
\infty & dx = 0
\end{cases}
\label{eq:findfirstt}
\end{equation}

We traverse the grid until we hit a non-empty cell.
The device pointer and array size from that cell are read from device memory.
We perform two triangle intersection tests per quad, using the technique from \cite{moller2005fast}.
If we hit the back-face of the first triangle, we can skip the test for the second triangle because they share the same normal.
We can also skip the second triangle if our first hit was successful.

\subsection{Results}
We initially only tested for hit vs non-hit.
No texturing or lighting techniques were applied.
Results were disappointing, as the performance was very poor (\textless 1 frame per second on the laptop machine), even after optimizing kernel register count and instruction latency.
The NVIDIA Nsight profiler showed that the kernel is mostly dependent on memory reads.

\section{Preprocessing Vertex Buffers}
In our second attempt, we obtain the vertex buffers before they are uploaded to OpenGL, and insert the quads in an acceleration structure fit for ray tracing.

\subsection{Obtaining the buffers}
In order to get the raw vertex buffers from Java to C++, we change three more classes.
%My approach was to replace the built-in \texttt{VertexBuffer} class with my own class, called \texttt{CppVertexBuffer}.
%Confusingly, the decompiled version of Minecraft has two classes called VertexBuffer in two separate packages.

We created our own version of \texttt{VertexBuffer}.
\texttt{VertexBuffer} contains a method called \texttt{bufferData} which uploads a \texttt{ByteBuffer} to OpenGL.
We modify the \texttt{bufferData} function such that the buffer is sent to C++ instead.
However, we need extra information aside from the vertex data, such as position and an id.
These can be obtained from \texttt{ChunkRenderDispatcher}.

\begin{itemize}
  \item \texttt{RenderChunk} \\
    %The class that represents a 16x16x16 chunk of blocks.
    %It contains one OpenGL vertex buffer per render layer.
    We replace the \texttt{VertexBuffer} field with our \texttt{CppVertexBuffer}.
    There is no inheritance, so we replace all references to \texttt{VertexBuffer}.
  \item \texttt{ChunkRenderDispatcher} \\
    In charge of uploading \texttt{RenderChunk}s to OpenGL.
    We pass an additional position parameter to the uploading routine.
  \item \texttt{VertexBufferUploader} \\
  Passes calls from \texttt{ChunkRenderDispatcher} to \texttt{RenderChunk}.
  We change this class to support \texttt{CppVertexBuffer}.
\end{itemize}

\subsection{C++}
Not ray tracing the VBOs directly means we do not have to map and unmap them every frame, which saves us quite a bit of overhead.
As acceleration structure, we have chosen to use an octree.
An octree lets us divide a RenderChunk evenly, while culling a lot of nodes per collision hit.
It is also cheap to build, as we can iterate over the quads and fit them to a leaf.
There will be one octree for every RenderChunk, which means the octree will be 4 levels deep ($16^{3} = 8^{4} = 4096$).

When we receive a vertex buffer from Minecraft, we build an octree.
Our implementation of the octree consists of an array of integers:

\begin{center}
  \begin{tabular}{|l|l|l|l|l|l|l|l|c|l|l|l|l|l|l|l|l|} \cline{1-8} \cline{10-17}
    0 & 0 & 8 & 0 & 64 & 0 & 0 & 0 & & 0 & 16 & 0 & 0 & 0 & 0 & 0 & 0 \\ \cline{1-8} \cline{10-17}
  \end{tabular}
\end{center}

Every node in the array consists of 8 integers.
A number indicates an offset in the array.
Zero means the node is empty.
In this example, the third child of the first node is non-empty.
It contains the number 8, so we jump to the node located at element 8 in the array.
The second child of this node is 16, so we jump to element 16.
This continues until we found a node after 4 jumps.
Then, the first integer in the node shows the amount of quads, followed by the indices of every quad in that cell.

The octree is built as follows:
\begin{enumerate}
  \item Iterate over all quads in the vertex buffer
  \item Find the cells this quad overlaps with
  \item Encode the overlapped cells using a Morton code\footnote{\url{https://en.wikipedia.org/wiki/Z-order_curve}}
  \item Store the encoded cells in a sorted list
  \item Create node array with empty root node
  \item Iterate over sorted list (depth-first due to Morton code property)
  \item If Morton code is equal to previous iteration, add this quad to the node
  \item Otherwise, add nodes depending on decoded Morton code, insert quad count (count ahead), and add first quad
\end{enumerate}
This method allows us to build node array in one go.
It is also GPU friendly by using array indices rather than pointers.
The vertex buffer and the octree are uploaded to CUDA.
We store the two in a struct, and put this struct in the RenderChunk grid.
Previously, we had two grids: one for vertex buffers, and one for array sizes.
Now, we have one grid for both octrees and buffer pointers.

Step 2 is actually a bit harder than it looks, because the quad vertices are positioned on grid corners.
This eliminates the option to simply use the \texttt{floor} function.
I needed to add a check for the direction of the edges, after researching how Minecraft did meshing (see Figure \ref{fig:cube}).

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=2]
  \coordinate (X) at (1,-1);
  \coordinate (Y) at (-1,1);
  
  \draw (1,1) -- (1,0) -- (2,0) -- (2,1);
  \draw[dotted]  (2,1) -- (1,1);
  \draw (1,3) -- (1,2) -- (2,2) -- (2,3) -- (1,3);
  \draw (3,2) -- (3,1) -- (4,1) -- (4,2) -- (3,2);
  \draw (1,2) -- (1,1) -- (2,1) -- (2,2) -- (1,2);  
  \draw (0,2) -- (0,1) -- (1,1) -- (1,2) -- (0,2);
  \draw (2,2) -- (2,1) -- (3,1) -- (3,2) -- (2,2);
  
  \draw (1.5,0.5)node{Bottom};
  \draw (1,1) node[below right] {$0$};
  \draw (1,0) node[above right] {$1$};
  \draw (2,0) node[above left] {$2$};
  \draw (2,1) node[below left] {$3$};
  
  \draw (1.5,2.5)node{Top};  
  \draw (1,3) node[below right] {$4$};
  \draw (1,2) node[above right] {$5$};
  \draw (2,2) node[above left] {$6$};
  \draw (2,3) node[below left] {$7$};
  
  \draw (3.5,1.5)node{Back};  
  \draw (3,2) node[below right] {$8$};
  \draw (3,1) node[above right] {$9$};
  \draw (4,1) node[above left] {$10$};
  \draw (4,2) node[below left] {$11$};
  
  \draw (1.5,1.5)node{Front};  
  \draw (1,2) node[below right] {$12$};
  \draw (1,1) node[above right] {$13$};
  \draw (2,1) node[above left] {$14$};
  \draw (2,2) node[below left] {$15$};
  
  \draw (0.5,1.5)node{Left};  
  \draw (0,2) node[below right] {$16$};
  \draw (0,1) node[above right] {$17$};
  \draw (1,1) node[above left] {$18$};
  \draw (1,2) node[below left] {$19$};
  
  \draw (2.5,1.5)node{Right};  
  \draw (2,2) node[below right] {$20$};
  \draw (2,1) node[above right] {$21$};
  \draw (3,1) node[above left] {$22$};
  \draw (3,2) node[below left] {$23$};
  
  \draw[->] (-0.5,-0.5) -- (1,-0.5)node[anchor=west]{$x$};
  \draw[->] (-0.5,-0.5) -- (-0.5,1)node[anchor=south]{$y$};
  \end{tikzpicture}
  \caption[Net of a single cube]{
    The net of a single cube in a RenderChunk, after Minecraft finished meshing.
    Numbers indicate the order of vertices in the vertex buffer.
    There is no index array, so no vertices are shared.
    Face order: bottom, top, back, front, left, right.
    The vertex order is counter-clockwise and starts at the top-left.
  }
  \label{fig:cube}
\end{figure}

\subsection{CUDA}
In CUDA, we replace the brute force collision test of all quads within a RenderChunk with a nested series of octree intersection tests.
This requires that we add a ray-AABB intersection function to the kernel.
A lot of variables can be reused during the nested for loop, so we are not sacrificing that many registers for it.
We also prevented creating a recursive function, which causes stack size problems on GPGPU programs.

\subsection{Results}
We were not able to finish debugging the octree implementation.
Theoretically, the memory access pattern is more favorable using this approach.
There is also a lot of room for optimizations once we have a proof of concept working.
The initial tests showed a result of 20+ frames per second on the desktop machine, but this information is not very useful if the kernel does not function properly.

\section{Conclusion}
There is still a lot of research that can be done in this area.
Finishing the octree implementation and being able to compare it with the first approach would be the initial goal.
Minecraft does not stitch quads together, which increases the polygon count.
This is probably a contributing factor to the poor performance of the brute force approach.

It has been shown that it is completely possible to implement a ray tracer in Minecraft.
This has been mostly possible through the use of Java ASM.
ASM is not the most elegant way of modding, but it is certainly powerful.

Trapping access violations from your own modules using Visual Studio is only feasible when using the 2017 version.

Using a loader DLL between Java and C++ is a good technique. However, proper memory management is essential.

\section{Future work}
Only a small fraction of the total work has been investigated.
We currently only tested for hit versus miss on opaque blocks.
No texturing or lighting calculations were done.
Here is a list of things that could also be ray traced in-game:
\begin{itemize}
  \item Non-opaque blocks (Cutout, Cutout Mipped, Translucent)
  \item Model blocks (chests, enchanting tables)
  \item Non-playable characters (animals, enemies)
  \item Viewmodels (player-held items)
  \item Weather and particle effects
  \item Camera effects (Nausea, sprinting, teleportation)
  \item Dropped items
\end{itemize}
Another question is: What will the rays do once they hit a surface? Preferably, we would like to obtain material information when hitting an object, but we currently only store texture and lighting coordinates in the vertex data.
Getting to know if we hit glass or water for example would make an interesting challenge.
It is possible to hijack the Minecraft meshing procedure through heavy use of Java ASM, but no attempt was made.
We could perhaps try to extract material information during that stage.

\bibliography{minecraft_ray_traced}{}
%\bibliographystyle{plain}
\bibliographystyle{apalike}

% TODO: Java class diagrams(minecraft, raytracer)

\end{document}
