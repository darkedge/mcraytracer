%\documentclass[]{scrartcl}
\documentclass[]{article}
% sans-serif font
\renewcommand{\familydefault}{\sfdefault}

% Bibtex citations
%\usepackage{cite}
% sequence diagrams
\usepackage{pgf-umlsd}
% one inch margins
\usepackage[a4paper, margin=1in]{geometry}
% url referencing
\usepackage{url}
% show reference and figure lists in table of contents
\usepackage[nottoc,numbib]{tocbibind}
% add number to list of figures in table of contents
\renewcommand{\listoffigures}{\begingroup
\tocsection
\tocfile{\listfigurename}{lof}
\endgroup}

\usepackage{tikz,tkz-euclide}
\usepackage{tikz-qtree}
% tikz features
\usetikzlibrary{decorations.pathreplacing,angles,quotes,shapes,arrows,fit}
\usetikzlibrary{calc} % coordinates
\usetikzlibrary{arrows.meta} % better arrows
\usetikzlibrary{trees} % this is to allow the fork right path
\usetkzobj{all}

% real numbers symbol
\usepackage{amssymb}

\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  breaklines=true,
  %keywordstyle=\color{blue},
  %commentstyle=\color{olive},
}

% set default arrow
\tikzset{>=Latex}

% define arrow style
\tikzstyle{arw}=[-{Latex[length=3mm]}]

% extra math
\usepackage{mathtools}
% icons!
\usepackage{fontawesome}
% quotations
\usepackage{csquotes}

% bigger dot for multiplication
\makeatletter
\newcommand*\bigcdot{\mathpalette\bigcdot@{.5}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother

\title{Minecraft: Ray Traced}
%\subtitle{Or: A dynamic acceleration structure for voxel worlds}
\author{Marco Jonkers}

\begin{document}

%\maketitle

\begin{titlepage}
  \centering
  \includegraphics[scale=0.5]{eng_logofc_uas.jpg}\par\vspace{1cm}
  {\scshape\LARGE NHTV Breda University of Applied Sciences\par}
  \vspace{1cm}
  {\scshape\Large Personal project\par}
  \vspace{1.5cm}
  {\huge\bfseries Minecraft: Ray Traced\par}
  \vspace{2cm}
  {\Large Marco Jonkers\par}
  \vspace{0.5cm}
  {Supervisor: David H{\"o}rchner\par}

  
  \vspace{2cm}
  
  \begin{abstract}
    This project attempts to implement a GPU ray tracer in the video game Minecraft, using CUDA.
    The ray tracing itself is done in CUDA. At first, I attempt to ray trace the vertex buffers given by Minecraft. Then, I implement my own data structures for increased performance.
  \end{abstract}
  
  \vfill
  
  % Bottom of the page
  {\large \today\par}
\end{titlepage}

% TODO: Do I want to keep the list of figures?

\newpage
\tableofcontents
\newpage
\listoffigures
\newpage

\section{Introduction}
Minecraft is a 2011 first-person sandbox video game.
Originally created by Markus \enquote{Notch} Persson, it is currently maintained by Mojang.


Minecraft comes in multiple editions, for various platforms. This paper focuses on the PC version of Minecraft, released for Windows, macOS, and Linux.
The PC version is written in Java.

In Minecraft, the game world consists of a three-dimensional grid.
The world is procedurally generated, using a 
mostly comprised of unit blocks, as shown in Figure \ref{fig:ss-worldgen}.

\begin{figure}
  \includegraphics[width=\textwidth]{ss-worldgen.png}
  \centering
  \caption{In-game screenshot of Minecraft, without heads-up display (HUD) or viewmodel.}
  \label{fig:ss-worldgen}
\end{figure}

\section{Related Work}

\section{Minecraft Renderer}
Minecraft uses multi-threaded chunk generation.
Minecraft uses OpenGL.
Minecraft has two options for rendering static geometry:
\begin{description}
  \item[Display Lists] An OpenGL 1.0 core function.
    Display Lists are a group of OpenGL commands that have been compiled and sent to the GPU.
    An object can then be drawn by calling the list.
    The list can be reused, which means you do not have to send the data over again.
  \item[Vertex Buffer Objects] Vertex Buffer Objects (\enquote{VBOs}) were available in OpenGL 1.4 through an extension, and were later added to the core specification in version 2.1.
    This feature allows you to have a buffer with vertex information, and telling the driver where and how the attributes are stored in the buffer.
\end{description}
My project makes use of Minecraft's VBO rendering, because I can extract the vertex data from the buffers.

\subsection{RenderChunks}
See figure \ref{fig:renderchunk}.

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.3]
  \foreach \x in{0,...,16} {
    \draw[very thin] (0,\x ,16) -- (16,\x ,16);
    \draw[very thin] (\x ,0,16) -- (\x ,16,16);
    \draw[very thin] (16,\x ,16) -- (16,\x ,0);
    \draw[very thin] (\x ,16,16) -- (\x ,16,0);
    \draw[very thin] (16,0,\x ) -- (16,16,\x );
    \draw[very thin] (0,16,\x ) -- (16,16,\x );
  }
  % right
  \draw[dashed] (16,0,0) -- ++(5,0,0);
  \draw[dashed] (16,16,0) -- ++(5,0,0);
  \draw[dashed] (16,16,16) -- ++(5,0,0);
  \draw[dashed] (16,0,16) -- ++(5,0,0);
  % top
  \draw[dashed] (0,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,16) -- ++(0,5,0);
  \draw[dashed] (0,16,16) -- ++(0,5,0);
  % back
  \draw[dashed] (0,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,0,0) -- ++(0,0,-5);
  % front
  \draw[dashed] (0,16,16) -- ++(0,0,5);
  \draw[dashed] (16,16,16) -- ++(0,0,5);
  \draw[dashed] (16,0,16) -- ++(0,0,5);
  \draw[dashed] (0,0,16) -- ++(0,0,5);
  % left
  \draw[dashed] (0,0,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,0) -- ++(-5,0,0);
  % bottom
  \draw[dashed] (16,0,0) -- ++(0,-5,0);
  \draw[dashed] (16,0,16) -- ++(0,-5,0);
  \draw[dashed] (0,0,16) -- ++(0,-5,0);
  % curly braces
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[left=15pt]{16} (0,16,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[below=15pt]{16} (16,0,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (16,0,16) -- node[below=15pt,right=10pt]{16} (16,0,0);
  \end{tikzpicture}
  \caption[Diagram of a RenderChunk]{A single, completely filled RenderChunk.}
  \label{fig:renderchunk}
\end{figure}

There are four geometry groups, based on texture properties.
\begin{description}
  \item[Solid] Uses textures that are fully opaque. Most world blocks are in this group.
  \item[Cutout] Uses textures that have transparent texels.
  \item[Mipped Cutout] Identical to Cutout, but mipmapped.
  \item[Translucent] Used for block which have partial transparency (alpha blending).
\end{description}

Vertex format:

\begin{tabular}{|l|r|r|r|} \hline
  Attribute & Type & \# & Bytes\\ \hline
  Position & float & 3 & 12 \\ \hline
  Color & byte & 4 & 4 \\ \hline
  Lightmap & float & 2 & 8 \\ \hline
  Texture & short & 2 & 4 \\ \hline
  Total &   &  & 28 \\ \hline
\end{tabular}

\subsection{Other rendering}
\texttt{TileEntitySpecialRenderer} etc.

\begin{figure}
  \includegraphics[width=\textwidth]{ss-layers.png}
  \centering
  \caption{One object from each render layer. From left to right: Cobblestone (Solid), Glass (Cutout), Hopper (Cutout Mipped), and Stained Glass (Translucent).}
  \label{fig:ss-layers}
\end{figure}
Every geometry group has its own vertex buffer.

% TODO: Big disclaimer that source code names all come from MCP, not Mojang
\section{Minecraft Forge}
Minecraft Forge (\enquote{Forge}) is a community created platform for developing and using modifications ("mods") for Minecraft.\footnote{Modification of Minecraft ("modding") is not officially supported by Mojang. For more information, visit \url{https://account.mojang.com/terms}}
\subsection{Setting up a mod development environment}
The Mod Development Kit (\enquote{MDK}) can be downloaded from the Forge website\footnote{\url{http://files.minecraftforge.net/}}.
The MDK distribution includes ForgeGradle\footnote{\url{https://github.com/MinecraftForge/ForgeGradle}}.
ForgeGradle is a plugin for the Gradle\footnote{\url{https://gradle.org/}} build system.
The Minecraft binaries are downloaded, and subsequently decompiled, deobfuscated, 
The classes are decompiled into srg names.

The Mod Coder Pack\footnote{\url{http://www.modcoderpack.com/website/}} is a package which is used to decompile, change, and recompile Minecraft Java classes.

The Gradle tasks include:
\begin{enumerate}
  \item Download Minecraft .jar files.
  \item Decompile the Minecraft 
  \item Generate the Forge Minecraft binary
\end{enumerate}

Forge explicitly supports the Eclipse and IntelliJ integrated development environments (\enquote{IDEs}).
I used IntelliJ IDEA Community.
ForgeGradle gives you the option of debugging and building both client and server sides of Minecraft.

The path to my DLLs is passed to the virtual machine.

\subsection{Differences between development and release builds}
During development, Java loads my classpath directly.
In release mode, my class files would have to be compressed into an archive first.

\subsection{Changes to Minecraft source code}
Forge adds some new features to the Minecraft source code, in order to support multi-mod functionality.

\subsection{Creating a mod}
In general there are three approaches to creating a mod:
\begin{enumerate}
  \item Build a mod on top of the Forge Minecraft code
  \item Edit the Minecraft source directly
  \item Use class transformers in custom mod loading
\end{enumerate}
For most mods, the first approach is sufficient.
This also enables the developer to freely distribute their mod.
Editing the Minecraft source directly means that the mod cannot be redistributed, because the original Minecraft code is copyrighted.

\section{Hardware}
This project is developed on the following machines:

\begin{center}
  \begin{tabular}{| l || c | c |} \hline
    & Dell XPS 15 L502X & Desktop \\ \hline
    Operating System & \multicolumn{2}{c|}{Microsoft Windows 10 Pro 64-bit} \\ \hline
    Processor & Intel Core i7-2630QM & Intel Core i7-4790 \\ \hline
    Memory & 4 GB DDR3 & 8 GB DDR3 \\ \hline \hline
    GPU & NVIDIA GeForce GT 540M & NVIDIA GeForce GTX 970\\ \hline
    - CUDA Cores & 96 & 1664 \\ \hline
    - Shader Multiprocessors & 2 & 13 \\ \hline
    - Compute Capability & 2.1 & 5.2 \\ \hline
    %- Processor Clock & 1344 MHz &  \\ \hline
    - Memory Clock & 900 MHz & 7010 MHz \\ \hline
    - Graphics Clock & 672 MHz & 1140 MHz \\ \hline
    - Memory & 2 GB & 4 GB \\ \hline % \footnote{\url{https://blogs.nvidia.com/blog/2015/02/24/gtx-970/}}
  \end{tabular}
\end{center}

\section{C++ and CUDA}
I wanted to create a GPU ray tracer.
There are various methods to achieve this. 
I wanted to take advantage of the vertex buffers in CUDA.
Because Minecraft uses OpenGL through the LWJGL\footnote{\url{https://www.lwjgl.org/}} library, I could have chosen to use OpenGL compute shaders.
However, I have no experience with OpenGL compute shaders, whereas I do have experience with NVIDIA CUDA.

There exist Java bindings for CUDA, but using C++ removes my dependency on a binding layer.
\subsection{Java Native Interface}
Java Native Interface (\enquote{JNI}) is a programming framework that allows for Java code to interact with native code.
\subsubsection{javah}
\texttt{javah} is a tool that generates C header and source files for Java classes that declare native methods.
I use the generated header file in my Visual Studio project.
The header file is compatible with C++ code bases as it includes an \texttt{\#ifdef \_\_cplusplus} directive which prepends an \texttt{extern \char`\"C"} to the function declarations.
\cite{noauthor_jni_nodate} Function parameters are passed as the following:
% TODO: citation

\begin{center}
\begin{tabular}{|l|l|l|} \hline
  Java & C++ & represented type \\ \hline
  boolean & jboolean & unsigned 8 bits \\ 
  byte & jbyte & signed 8 bits \\ 
  char & jchar & unsigned 16 bits \\ 
  short & jshort & signed 16 bits \\ 
  int & jint & signed 32 bits \\ 
  long & jlong & signed 64 bits \\ 
  float & jfloat & 32 bits \\ 
  double & jdouble & 64 bits \\ 
  void & void & not applicable \\ \hline
\end{tabular}
\end{center}

Additionally, Java objects are passed as (subclasses of) \texttt{jobject} instances, as can be seen in Figure \ref{fig:jobject}.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[level distance=1.25in,,scale=.75]
    \tikzset{edge from parent/.style= 
      {thick, draw,
        edge from parent fork right},every tree node/.style={draw,minimum width=1in,text width=1in, align=center},grow'=right}
    \Tree 
    [.\texttt{jobject}
    [.\texttt{jclass} ]
    [.\texttt{jstring} ]
    [.\texttt{jthrowable} ]
    [.\texttt{jarray}
    [.\texttt{jobjectArray} ]
    [.\texttt{jbooleanArray} ]
    [.\texttt{jbyteArray} ]
    [.\texttt{jcharArray} ]
    [.\texttt{jshortArray} ]
    [.\texttt{jintArray} ]
    [.\texttt{jlongArray} ]
    [.\texttt{jfloatArray} ]
    [.\texttt{jdoubleArray} ]
    ]
    ]
    \end{tikzpicture}
  \end{center}
\caption{C++ inheritance diagram}
\label{fig:jobject}
\end{figure}

\subsection{CUDA}
CUDA is a parallel computing platform and programming model developed by NVIDIA.
It is only compatible with NVIDIA hardware.
CUDA has two APIs: Runtime and Driver.
\subsection{CUDA/OpenGL interoperability}
CUDA provides an API for operating on OpenGL primitives.
\begin{enumerate}
  \item Run the ray tracing kernel
  \item Map the OpenGL texture to a CUDA array
  \item Copy the kernel output buffer to the CUDA array
\end{enumerate}

\subsection{Creating a Visual Studio project}
For setting up the native part of the mod, I created a Visual Studio CUDA project.
NVIDIA has a CUDA plugin for Visual Studio called Nsight.

\tikzstyle{dll}=[draw,rectangle,text width=2cm,text centered,node distance=3.5cm]
\tikzstyle{java}=[draw,rectangle,inner sep=0.3cm,rounded corners,node distance=3.5cm,minimum width=8em,minimum height=4em]
\begin{figure}
  \begin{tikzpicture}[auto]
  % loader.dll
  \node[dll] (loader_dll) {loader.dll};
  % raytracer.dll
  \node[dll,right of=loader_dll] (raytracer_dll) {raytracer.dll};
  % Raytracer.class
  \node[java,fit=(loader_dll)] (container) {};
  % Raytracer.class label
  \node at (container.north)[above](raytracer){Raytracer.class};
  % mcraytracer.jar
  \node[java,fit=(container)(raytracer)](minecraft){};
  % mcraytracer.jar label
  \node at (minecraft.north)[above](jar){mcraytracer.jar};
  % minecraft jar
  \node[java,left of=raytracer](minecraft_jar){minecraft.jar};
  % Forge Minecraft
  \node[java,below of=minecraft_jar](forge_minecraft){Forge Minecraft};
  \node[java,right of=forge_minecraft](external_libraries){External libraries};
  % Java Virtual Machine
  \node[java,fit=(jar)(minecraft)(minecraft_jar)(forge_minecraft)(external_libraries)](java){};
  % Java Virtual Machine label
  \node at (java.north)[above](vm_label){Java Virtual Machine};
  
  \draw [->] (loader_dll) -- node {} (raytracer_dll);
  %\draw [<->] (minecraft_jar) -- node {} (minecraft);
  \end{tikzpicture}
  \centering
  \caption[Binary interaction]{Interaction diagram of the different binaries.}
  \label{fig:modules}
\end{figure}

\subsubsection{Reloading C++}
Java IDEs such as IntelliJ support hot-swapping of method bodies by using the HotSwap functionality of the Java Platform Debugger Architecture.
I created something similar for my native code by using a technique called DLL reloading.
Once a native library has been loaded by the JVM, I cannot make changes to it.
Therefore I am using a passthrough DLL, which passes the calls from Java to another DLL.
I have shown this in Figure \ref{fig:modules}.

\subsubsection{Setting up the Visual Studio debugger}
IntelliJ debug sessions are good for testing if my Java ASM works correctly, and if my JNI bindings are set up properly.
However, if an error occurs a native part, the debug session ends immediately.
The crash output from IntelliJ is unable to use the debug information from Visual Studio.
I wanted to use the Visual Studio debugger for the native part.
I had to launch java.exe with the right command line arguments and working directory.
I looked at the launch parameters given to java.exe when starting a debug session from IntelliJ.
The Visual Studio debugger can be configured to launch Minecraft by copying the command line arguments from an IntelliJ debug session.
The JVM uses the access violation signal internally for its memory exception handling.
When an access violation is thrown from the JVM, this can be safely ignored.
However, Visual Studio can easily block hundreds of these signals.
Visual Studio 2017 offers an option to ignore certain exceptions per module, allowing me to break on access violations in my own native code while ignoring those coming from the JVM.

\subsection{Kernel overhead on Windows}
There is a non-trivial amount of overhead attached to the launch of a CUDA kernel on Windows.
This is due to the Windows Display Driver Model (\enquote{WDDM}).
An alternative would be to use the Tesla Compute Cluster driver (\enquote{TCC}).
Unfortunately, TCC is not available for GeForce GPUs.
Additionally, GPUs in TCC cannot be connected to a display.

\section{Ray Tracing OpenGL Vertex Buffers}
My initial idea was to ray trace the uploaded VBOs from Minecraft directly.

\subsection{Forge Events}
%I wanted to see if I could make my mod work using the first approach.
%Forge adds hooks to the game loop which I could use to intercept the rendering code.
The \texttt{Raytracer} class listens to the following events:
\begin{itemize}
  \item \texttt{FMLInitializationEvent} \\
    As the name indicates, this event is fired when Forge is initializing Minecraft.
    This event is used to initialize the mod.
    Here I also obtain a reference to the \texttt{Minecraft} singleton class.
    The mod needs to be registered in the \texttt{ClientRegistry} in order to receive further Forge events.
  \item \texttt{TickEvent.ClientTickEvent} \\
    This event is fired 20 times per second, and can be regarded as the client-sided update function.
    I listen to this event to check for keyboard input changes.
  \item \texttt{GuiScreenEvent.InitGuiEvent.Pre} \\
    This is the first event that is fired when a window resize is detected.
    The event does not contain any resize information, so I track it manually.
    The resolution information in the \texttt{Minecraft} class is public, so I extract it from there.
    The information is passed to C++, such that the CUDA and OpenGL resources can be resized if they need to be.
    OpenGL supports resizing by calling \texttt{glTexImage2D} with the new information, without having to call \texttt{glGenTextures} again.
    In CUDA, it is required to unregister and re-register the associated graphics resource.
    The kernel output buffer is also resized. This uses a pair of \texttt{cudaFree} and \texttt{cudaMalloc} calls.

    % TODO: something about OpenGL textures and power of two?
  \item \texttt{TickEvent.RenderTickEvent} \\
    This event is fired when Minecraft starts rendering the next frame.
    
    In order to prevent Minecraft from drawing the world after I have done the ray tracing, I copy the \texttt{WorldClient} reference from \texttt{Minecraft}, and set the value in \texttt{Minecraft} to \texttt{null}.
    This effectively causes Minecraft to skip the rendering of the game world, because it has an internal check for the \texttt{WorldClient} there.
    If it is \texttt{null}, nothing is rendered.
    However, this also disables rendering of the game overlay, which contains elements like the player inventory and menu's.
    I manually draw the game overlay after drawing the ray tracing result to the screen.
  \item \texttt{GuiScreenEvent.DrawScreenEvent.Pre} \& \texttt{GuiScreenEvent.DrawScreenEvent.Post} \\
    I noticed that the background of the game overlay was solid instead of transparent.
    This is due to another check for the \texttt{WorldClient} instance during drawing.
    Because I previously made it \texttt{null}, I now have to restore it on the \texttt{GuiScreenEvent.DrawScreenEvent.Pre} event in order to draw the background.
    I set it back to null at the \texttt{GuiScreenEvent.DrawScreenEvent.Post} event.
  %\item \texttt{GuiOpenEvent} \\
    %Fired when the top-level menu changes.
\end{itemize}
I was able to draw a full-screen texture using CUDA and copy it to Minecraft using OpenGL.
However, I am not able to obtain the Minecraft vertex buffers using Forge Events alone.
That is where I either needed to change the Minecraft source directly, or use Java ASM.
I chose the second option.

% TODO: Did I already define what ASM is somewhere?
% TODO: This part assumes deobfuscated source code; make sure that's mentioned
\subsection{Using ASM}
Forge provides the \texttt{IFMLLoadingPlugin} interface for mods which have customized loading procedures.
It provides a method for adding class transformers, which can edit the Minecraft bytecode before it is loaded into the game.
An example of bytecode can be found in Figure \ref{fig:bytecode}.
We create a class transformer by implementing Forge's \texttt{IClassTransformer} interface, which contains a single method: \texttt{transform}.
Every time a Minecraft class is initialized, the method is called with its name and bytecode.
This is the general procedure if we want to change a method:

\begin{enumerate}
  \item Check the name of the class
  \item Parse the bytecode of the class to a \texttt{ClassNode}
  \item Find the method in the \texttt{MethodNode} list of the \texttt{ClassNode}
  \item Find the instruction in the \texttt{InsnList} list of the \texttt{MethodNode}
  \item Insert new instructions
  \item Remove old instructions
  \item Return the modified class as a byte array
\end{enumerate}

% TODO: Finish this sentence
%To minimize the amount of ASM changes, it is recommended to 
We changed the following classes:

\begin{itemize}
  \item \texttt{EntityRenderer} \\
    Contains the method \texttt{updateCameraAndRender} that calls \texttt{renderWorld} to render the world.
    We replace it with a call to a \texttt{Raytracer} method.
    An easy way to do this is by having a Singleton.
    This removes the need to introduce a new field in the modified class.
    It involves adding two instructions:
    \begin{itemize}
      \item \texttt{INVOKESTATIC} to put the Singleton on the stack
      \item \texttt{INVOKEVIRTUAL} to call the static function
    \end{itemize}
  \item \texttt{RenderGlobal} \\
    Contains a \texttt{ChunkRenderContainer} field that is initialized using a \texttt{VboRenderList}.
    It is a list of RenderChunks which is rebuilt every frame.
    We replace the construction of the \texttt{ChunkRenderContainer} by modifying the \texttt{NEW} and \texttt{INVOKESPECIAL} instructions to use our \texttt{RaytracerRenderList} instead.
    \texttt{RaytracerRenderList} overrides \texttt{ChunkRenderContainer} such that the list of \texttt{VertexBuffer}s is sent to C++ instead of being drawn using OpenGL.
\end{itemize}
The sequence diagram can be found in Figure \ref{fig:sequence}.

% TODO: the basic concepts of render layers should be known at this point

\lstdefinelanguage{bytecode} % Unused
{
  % list of keywords
  morekeywords={
    ALOAD,
    INVOKESPECIAL,
    PUTFIELD,
    INVOKESTATIC,
    RETURN,
    LOCALVARIABLE,
  },
  sensitive=true, % keywords are not case-sensitive
  morecomment=[l]{//}, % l is for line comment
  %morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  %morestring=[b]" % defines that strings are enclosed in double quotes
}
\begin{figure}
\begin{lstlisting}[breaklines,frame=single]
// Java
public Renderer(Raytracer raytracer) {
    this.raytracer = raytracer;
    this.mc = Minecraft.getMinecraft();
}

// Bytecode
public <init>(Lcom/marcojonkers/mcraytracer/Raytracer;)V
ALOAD 0
INVOKESPECIAL java/lang/Object.<init> ()V
ALOAD 0
ALOAD 1
PUTFIELD com/marcojonkers/mcraytracer/Renderer.raytracer : Lcom/marcojonkers/mcraytracer/Raytracer;
ALOAD 0
INVOKESTATIC net/minecraft/client/Minecraft.getMinecraft ()Lnet/minecraft/client/Minecraft;
PUTFIELD com/marcojonkers/mcraytracer/Renderer.mc : Lnet/minecraft/client/Minecraft;
RETURN
LOCALVARIABLE this Lcom/marcojonkers/mcraytracer/Renderer; 0
LOCALVARIABLE raytracer Lcom/marcojonkers/mcraytracer/Raytracer; 1
\end{lstlisting}
\caption[Example bytecode]{Example bytecode for the constructor of my \texttt{Renderer} class. Note the use of Java VM signatures. \texttt{ALOAD} puts a \texttt{LOCALVARIABLE} (listed at the bottom) on the stack. Method parameters and \texttt{this} are implicit local variables.}
\label{fig:bytecode}
\end{figure}

% Code flow structure
\begin{figure}
  \centering
  \begin{sequencediagram}
    \newthread{minecraft}{Forge Minecraft}{}
    \newinst[2]{forge}{Forge Mod}{}
    \newinst[2]{loader}{C++/CUDA}{}
    \begin{call}{minecraft}{transform()}{forge}{}
    \end{call}
    \postlevel
    \begin{call}{minecraft}{Raytracer()}{forge}{}
      \begin{call}{forge}{init()}{loader}{}
      \end{call}
    \end{call}
    %    \postlevel
    %    \begin{call}{minecraft}{onPreInitGuiEvent()}{forge}{}
    %      \begin{call}{forge}{resize()}{loader}{}
    %      \end{call}
    %    \end{call}
    \begin{sdblock}{Main Loop}{}
      \begin{call}{minecraft}{initialize()}{forge}{}
        \begin{call}{forge}{setViewEntity()}{loader}{}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{addRenderChunk()}{forge}{}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderChunkLayer()}{forge}{}
        \begin{call}{forge}{setVertexBuffer()}{loader}{}
          \begin{call}{loader}{GetIntField()}{loader}{glBufferId}
          \end{call}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderWorld()}{forge}{}
        \begin{call}{forge}{setViewingPlane()}{loader}{}
        \end{call}
        \postlevel
        \begin{call}{forge}{raytrace()}{loader}{texture ID}
          \begin{call}{loader}{Kernel()}{loader}{}
          \end{call}
        \end{call}
      \end{call}
    \end{sdblock}
  \end{sequencediagram}
  \caption[Sequence diagram]{Sequence diagram showing interaction between the modules}
  \label{fig:sequence}
\end{figure}

\subsection{Camera construction}
We unproject the corners of the screen to world space by applying the inverse view-projection matrix from the game.
These coordinates, along with the player position and the vertical field of view ("FoV") from the game settings are passed to C++.
With this information, we can calculate the ray origin and view pyramid, as shown in Figure \ref{fig:rayorigin}.

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.5]
  \coordinate (A) at (0,0,0);
  \coordinate (B) at (0,0,16);
  \coordinate (C) at (0,9,0);
  \coordinate (D) at (0,9,16);
  \coordinate (E) at (0,4.5,8);
  \coordinate (F) at (-8,4.5,8);
  \coordinate (G) at (0,4.5,0);
  \coordinate (H) at (0,9,8);
  \coordinate (I) at (-5,0,0);
  \draw[arw] (A) node[anchor=north]{$P$} -- (B) node[anchor=north]{$Q$};
  \draw[arw] (A) -- (C) node[anchor=south]{$R$};
  \draw[dotted] (H) -- (E);
  \draw[dashed] (B) -- (D);
  \draw[dashed] (C) -- (D);
  \tkzMarkRightAngle[draw=black,size=0.5](H,E,F)
  \tkzMarkRightAngle[draw=black,size=0.5](C,A,I)
  \tkzMarkRightAngle[draw=black,size=0.5](C,G,E)
  \tkzMarkSegment[pos=.75,mark=|](A,C)
  \tkzMarkSegment[pos=.25,mark=|](A,C)
  
  % eye point stuff
  \draw[dotted] (E) node[anchor=north west]{$S$} -- (F) node[anchor=east]{\faVideoCamera};
  \draw[arw] (A) -- node[anchor=north west]{$\vec{u}$} (I);
  \draw[dotted] (H) -- (F);
  \draw[dotted] (G) -- (E);
  \pic [draw, -, "$\theta$", angle eccentricity=1.5] {angle = E--F--H};
  \end{tikzpicture}
  
  \begin{align}
  \theta& = \frac{vertical\ field\ of\ view}{2} \nonumber \\
  \vec{u}& = \overrightarrow{PQ}\times\overrightarrow{PR} \nonumber \\
  S& = \frac{Q + R}{2} \nonumber \\
  \text{\faVideoCamera}_{pos}& = S + Normalize(\vec{u}) \bigcdot\frac{\lvert\lvert\overrightarrow{PR}\rvert\rvert}{2 \tan\left(\theta\right)} \nonumber
  \end{align}
  \caption{Ray origin calculations}
  \label{fig:rayorigin}
\end{figure}

\subsection{C++}
In C++, we use JNI calls to obtain the OpenGL buffer ID and index count of the \texttt{VertexBuffer}, as the fields are marked \texttt{private} in Java.
Empty buffers are discarded.
We register the buffer in CUDA to obtain a \texttt{cudaGraphicsResource}.
Each buffer must be registered exactly once.
We store the \texttt{cudaGraphicsResource} handles in a three-dimensional array (see Figure \ref{fig:grid}).
The size of the array is defined by the render distance option in the game settings.
The render distance is defined in chunks (minimum = 2, maximum = 16 on 32-bit Java, 32 on 64-bit Java).

The grid is indexed $x,z,y$.
The handles are placed in the grid such that the player chunk is in the center of the $x$\nobreakdash--$z$~plane:
\begin{align}
  x_{grid} &= \left\lfloor\frac{x_{player}}{16}\right\rfloor - \frac{x_{chunk}}{16} + \texttt{MAX\_RENDER\_DISTANCE} \nonumber \\
  y_{grid} &= \left\lfloor\frac{y_{player}}{16}\right\rfloor \nonumber \\
  z_{grid} &= \left\lfloor\frac{z_{player}}{16}\right\rfloor - \frac{z_{chunk}}{16} + \texttt{MAX\_RENDER\_DISTANCE} \nonumber
\end{align}

When the player moves to a new chunk, we shift the grid along the $x$\nobreakdash--$z$~plane.
This allows us to keep the vertical \texttt{RenderChunk}s contiguous in memory.

\begin{figure}
  \centering
  \begin{tikzpicture}
  \draw[step=0.5cm,very thin,opacity=0.2] (-6,-6) grid (6.5,6.5);
  %\fill (0,0) -- (0.5,0) -- (0.5,0.5) -- (0,0.5) -- (0,0);
  \draw[dashed] (-6,0) -- (6.5,0);
  \draw[dashed] (-6,0.5) -- (6.5,0.5);
  \draw[dashed] (0,-6) -- (0,6.5);
  \draw[dashed] (0.5,-6) -- (0.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0.5,0.5) -- node[above=15pt] {12} (6.5,0.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0.5) -- node[left=15pt] {12} (0,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,6.5) -- node[above=15pt] {35} (6.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,-6) -- node[left=15pt] {35} (-6,6.5);
  \draw[fill] (0.25,0.25) circle (.5ex);
  
  % view frustum
  \draw (0.25,0.25) -- (-6,5.25);
  \draw (0.25,0.25) -- (6.5,5.25);
  \fill[color=gray,opacity=0.3] (-6,6.5) -- (-6,5.25) -- (0.25,0.25) -- (6.5,5.25) -- (6.5,6.5);
  
  %\draw[decoration={brace,mirror,raise=5pt},decorate] (0.5,0) -- node[below=6pt] {Render distance} (6.5,0);
  \end{tikzpicture}
  \caption[Top-down view of vertex buffer array]{
    A top-down view of the vertex buffer array, assuming a render distance of 12.
    The player's view cone is shown facing north.
    Each cell contains 16 \texttt{RenderChunk}s.
    When the player crosses a horizontal chunk boundary, every buffer in the grid is moved once space.
  }
  \label{fig:grid}
\end{figure}

After all \texttt{RenderChunk}s have been passed to C++ for the current frame, we obtain a device pointer for every \texttt{cudaGraphicsResource}.
These point to vertex data on the GPU and can be used in a CUDA kernel.
We use \texttt{cudaMemcpy} to copy the device pointers and array sizes from host to device memory.
Before we send the player position to the kernel, we transform it to chunk space:
\begin{equation}
f(x) = \frac{x}{16} - \left\lfloor\frac{x}{16}\right\rfloor
\end{equation}
This maps the player's position to $[0, 1)$, which is suitable for grid traversal.

% TODO: Explain thread groups before this
\subsection{CUDA}
We define the CUDA block size to be 8x8 threads.
Every pixel (assuming Minecraft's default resolution of 854x480) will run the kernel to fire a ray.
The implicit CUDA variables \texttt{blockIdx} and \texttt{threadIdx} are used in the kernel to calculate which pixel is being processed.
We calculate the ray direction for every pixel by linearly interpolating the corners of the viewport (refer to Figure \ref{fig:rayorigin}):

\begin{equation}
  Lerp(a, b, t) = a + t \bigcdot (b-a)
\end{equation}

\begin{equation}
  Normalize(\vec{v}) = \frac{\vec{v}}{\lvert\lvert\vec{v}\rvert\rvert}
\end{equation}

\begin{displaymath}
  dir_{ray} = Normalize(Lerp(P, Q, u) + Lerp(P, R) - P - pos_{camera})
\end{displaymath}

We use this in a 3D voxel traversal algorithm from \cite{amanatides1987fast}.
Amanatides et al. do not explain how to obtain the value of $t$ at which a ray crosses the first voxel boundary.
I have put the method in equation \ref{eq:findfirstt}.

\begin{equation}
f(x, dx) =
\begin{cases}
\frac{\lceil x \rceil - x}{\lvert dx \rvert} & dx > 0 \\
\frac{x - \lfloor x \rfloor}{\lvert dx \rvert} & dx < 0 \\
\infty & dx = 0
\end{cases}
\label{eq:findfirstt}
\end{equation}

We traverse the grid until we hit a non-empty cell.
The device pointer and array size from that cell are read from device memory.
We perform two triangle intersection tests per quad, using the technique from \cite{moller2005fast}.
If we hit the back-face of the first triangle, we can skip the test for the second triangle because they share the same normal.
We can also skip the second triangle if our first hit was successful.

\subsection{Results}
We initially only tested for hit vs non-hit.
No texturing or lighting techniques were applied.
Results were disappointing.
The NVIDIA NSight profiler showed that the kernel is mostly dependent on memory reads.

\section{Preprocessing Vertex Buffers}

\subsection{Obtaining the buffers}
In order to get the raw vertex buffers from Java to C++, we change three more classes.
%My approach was to replace the built-in \texttt{VertexBuffer} class with my own class, called \texttt{CppVertexBuffer}.
%Confusingly, the decompiled version of Minecraft has two classes called VertexBuffer in two separate packages.

We created our own version of \texttt{VertexBuffer}.
\texttt{VertexBuffer} contains a method called \texttt{bufferData} which uploads a \texttt{ByteBuffer} to OpenGL.
We modify the \texttt{bufferData} function such that 
We need extra information from \texttt{ChunkRenderDispatcher}.

\begin{itemize}
  \item \texttt{RenderChunk} \\
    %The class that represents a 16x16x16 chunk of blocks.
    %It contains one OpenGL vertex buffer per render layer.
    We replace the \texttt{VertexBuffer} field with our \texttt{CppVertexBuffer}.
    There is no inheritance, so we replace all references to \texttt{VertexBuffer}.
  \item \texttt{ChunkRenderDispatcher} \\
    In charge of uploading \texttt{RenderChunk}s to OpenGL.
  \item \texttt{VertexBufferUploader} \\
  Passes calls from \texttt{ChunkRenderDispatcher} to \texttt{RenderChunk}.
  We change this class to support \texttt{CppVertexBuffer}.
  
\end{itemize}

\subsection{C++}

\subsection{CUDA}

\subsection{Results}

\section{Conclusion}

\section{Future work}
I only got to work on the world rendering of the game.
Viewmodels (player-held items) are not ray traced.
Non-playable characters (\enquote{NPCs}) are not ray traced.

\bibliography{minecraft_ray_traced}{}
%\bibliographystyle{plain}
\bibliographystyle{apalike}

% TODO: Java class diagrams(minecraft, raytracer)

\end{document}
