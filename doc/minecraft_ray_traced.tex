%\documentclass[]{scrartcl}
\documentclass[]{article}
% sans-serif font
\renewcommand{\familydefault}{\sfdefault}
% Bibtex citations
\usepackage{cite}
% sequence diagrams
\usepackage{pgf-umlsd}
% one inch margins
\usepackage[a4paper, margin=1in]{geometry}
% url referencing
\usepackage{url}

\usepackage{tikz,tkz-euclide}
% tikz features
\usetikzlibrary{decorations.pathreplacing,angles,quotes,shapes,arrows,fit}
\usetikzlibrary{calc} % coordinates
\usetikzlibrary{arrows.meta} % better arrows
\usetkzobj{all}

% set default arrow
\tikzset{>=Latex}

% define arrow style
\tikzstyle{arw}=[-{Latex[length=3mm]}]

% extra math
\usepackage{mathtools}

\title{Minecraft: Ray Traced}
%\subtitle{Or: A dynamic acceleration structure for voxel worlds}
\author{Marco Jonkers}

\begin{document}

\maketitle

\begin{abstract}
This project attempts to implement a GPU ray tracer in the video game Minecraft, using CUDA.
The ray tracing itself is done in CUDA. At first, I attempt to ray trace the vertex buffers given by Minecraft. Then, I implement my own data structures for increased performance.
\end{abstract}

\section{Introduction}
Similar to other ray tracing research projects by Intel Corporation.
Also shortly explain the benefits of ray tracing versus regular rasterization.
Minecraft's world is made up of voxels, which is nice for ray tracing.

\section{Project Setup}
Here I explain how the project is set up and the technologies involved.
Minecraft is coded in Java.
The Minecraft Forge project allows me to do two things:
  Listen to specific events using pre-installed hooks
  Edit Minecraft bytecode before it is loaded
Using Java Native Interface (JNI), I can call into C++ code from Java.
The C++ code contains the CUDA kernel.
Data is passed between OpenGL and CUDA using CUDA's graphics interop layer.

I am using the Minecraft Forge API.
Forge is built on top of the Mod Coder Pack (MCP).
MCP is a tool for decompiling Minecraft.
A copy of the game is obtained by using the official installer from Mojang.
Forge uses Gradle.
During development, Java loads my classpath directly.
In release mode, my class files would have to be compressed into an archive first.
The path to my DLLs is passed to the virtual machine.

\section{Minecraft Rendering System}
There are four geometry groups:
\begin{description}
  \item[Solid] This is solid geometry.
  \item[Cutout] Used for glass.
  \item[Mipped Cutout] Identical to Cutout, but mipmapped.
  \item[Translucent] Used for block which have partial transparency (alpha blending).
\end{description}
Every geometry group has its own vertex buffer.

\section{Raytracing Minecraft's Vertex Buffers Directly}

I explain something here that is found in Figure ~\ref{fig:sequence}.
\subsection{Viewport and Ray Origin}
The viewport is passed from Java to C++ using ByteBuffers.

\section{Challenges}
The challenges of this project include:
\begin{description}
  \item [Ray tracing performance] Because of gameplay.
  \item [Acceleration structure rebuild speed] Because of gameplay.
\end{description}

\section{Static Geometry}
Test for citing \cite{amanatides1987fast}.

I am also citing \cite{ivson2009gpu}.

I am also citing \cite{reinhard2000dynamic}.

\section{Dynamic Geometry}
This section describes ray tracing dynamic objects, such as NPCs.

\section{Benchmarks}


\section{Future work}
Future work is addressed here.

\bibliography{minecraft_ray_traced}{}
\bibliographystyle{plain}
%\bibliographystyle{apalike}

\listoffigures

% Code flow structure
\begin{figure}
  \centering
  \label{fig:sequence}
  \begin{sequencediagram}
    \newthread{minecraft}{Forge Minecraft}{}
    \newinst[2]{forge}{Forge Mod}{}
    \newinst[2]{loader}{C++/CUDA}{}
    \begin{call}{minecraft}{transform()}{forge}{}
    \end{call}
    \postlevel
    \begin{call}{minecraft}{Raytracer()}{forge}{}
      \begin{call}{forge}{init()}{loader}{}
      \end{call}
    \end{call}
    %    \postlevel
    %    \begin{call}{minecraft}{onPreInitGuiEvent()}{forge}{}
    %      \begin{call}{forge}{resize()}{loader}{}
    %      \end{call}
    %    \end{call}
    \begin{sdblock}{Main Loop}{}
      \begin{call}{minecraft}{initialize()}{forge}{}
        \begin{call}{forge}{setViewEntity()}{loader}{}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{addRenderChunk()}{forge}{}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderChunkLayer()}{forge}{}
        \begin{call}{forge}{setVertexBuffer()}{loader}{}
          \begin{call}{loader}{GetIntField()}{loader}{glBufferId}
          \end{call}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderWorld()}{forge}{}
        \begin{call}{forge}{setViewingPlane()}{loader}{}
        \end{call}
        \postlevel
        \begin{call}{forge}{raytrace()}{loader}{texture ID}
          \begin{call}{loader}{Kernel()}{loader}{}
          \end{call}
        \end{call}
      \end{call}
    \end{sdblock}
  \end{sequencediagram}
  \caption[Sequence diagram]{Sequence diagram showing interaction between the modules}
\end{figure}

% hfov = 102.4478577779882556443232935315
% ++(141.22392888899412782216164676575:6cm);
% ++(38.77607111100587217783835323425:6cm);

\begin{figure}
  \centering
  \begin{tikzpicture}
  \draw[step=0.5cm,very thin,opacity=0.2] (-6,-6) grid (6.5,6.5);
  %\fill (0,0) -- (0.5,0) -- (0.5,0.5) -- (0,0.5) -- (0,0);
  \draw[dashed] (-6,0) -- (6.5,0);
  \draw[dashed] (-6,0.5) -- (6.5,0.5);
  \draw[dashed] (0,-6) -- (0,6.5);
  \draw[dashed] (0.5,-6) -- (0.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0.5,0.5) -- node[above=15pt] {12} (6.5,0.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0.5) -- node[left=15pt] {12} (0,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,6.5) -- node[above=15pt] {35} (6.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,-6) -- node[left=15pt] {35} (-6,6.5);
  \draw[fill] (0.25,0.25) circle (.5ex);
  
  % view frustum
  \draw (0.25,0.25) -- (-6,5.25);
  \draw (0.25,0.25) -- (6.5,5.25);
  \fill[color=gray,opacity=0.3] (-6,6.5) -- (-6,5.25) -- (0.25,0.25) -- (6.5,5.25) -- (6.5,6.5);
  
  %\draw[decoration={brace,mirror,raise=5pt},decorate] (0.5,0) -- node[below=6pt] {Render distance} (6.5,0);
  \end{tikzpicture}
  \caption[Top-down view of vertex buffer array]{
    A top-down view of the vertex buffer array, assuming a render distance of 12.
    The player's view cone- is shown facing north.
    Each cell contains 16 RenderChunks.
    When the player crosses a horizontal chunk boundary, every buffer in the grid is move once space.
  }
\end{figure}

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.3]
  \foreach \x in{0,...,16} {
    \draw[very thin] (0,\x ,16) -- (16,\x ,16);
    \draw[very thin] (\x ,0,16) -- (\x ,16,16);
    \draw[very thin] (16,\x ,16) -- (16,\x ,0);
    \draw[very thin] (\x ,16,16) -- (\x ,16,0);
    \draw[very thin] (16,0,\x ) -- (16,16,\x );
    \draw[very thin] (0,16,\x ) -- (16,16,\x );
  }
  % right
  \draw[dashed] (16,0,0) -- ++(5,0,0);
  \draw[dashed] (16,16,0) -- ++(5,0,0);
  \draw[dashed] (16,16,16) -- ++(5,0,0);
  \draw[dashed] (16,0,16) -- ++(5,0,0);
  % top
  \draw[dashed] (0,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,16) -- ++(0,5,0);
  \draw[dashed] (0,16,16) -- ++(0,5,0);
  % back
  \draw[dashed] (0,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,0,0) -- ++(0,0,-5);
  % front
  \draw[dashed] (0,16,16) -- ++(0,0,5);
  \draw[dashed] (16,16,16) -- ++(0,0,5);
  \draw[dashed] (16,0,16) -- ++(0,0,5);
  \draw[dashed] (0,0,16) -- ++(0,0,5);
  % left
  \draw[dashed] (0,0,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,0) -- ++(-5,0,0);
  % bottom
  \draw[dashed] (16,0,0) -- ++(0,-5,0);
  \draw[dashed] (16,0,16) -- ++(0,-5,0);
  \draw[dashed] (0,0,16) -- ++(0,-5,0);
  % curly braces
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[left=15pt]{16} (0,16,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[below=15pt]{16} (16,0,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (16,0,16) -- node[below=15pt,right=10pt]{16} (16,0,0);
  \end{tikzpicture}
  \caption[Diagram of a RenderChunk]{A single, completely filled RenderChunk.}
\end{figure}

% TODO Rotate this diagram 90 degrees along Y axis
\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.5]
    \coordinate (A) at (0,0,0);
    \coordinate (B) at (16,0,0);
    \coordinate (C) at (0,9,0);
    \coordinate (D) at (16,9,0);
    \coordinate (E) at (8,4.5,0);
    \coordinate (F) at (8,4.5,16);
    \coordinate (G) at (0,4.5,0);
    \coordinate (H) at (8,9,0);
    \coordinate (I) at (0,0,5);
    \draw[arw] (A) node[anchor=north]{$p_0$} -- (B) node[anchor=north]{$p_1$};
    \draw[arw] (A) -- (C) node[anchor=south]{$p_2$};
    %\draw[arw] (A) -- (8,4.5) node[anchor=west]{$p_3$};
    \draw[dashed] (8,9,0) -- (E);
    %\draw[dashed] (8,0,0) -- (E);
    \draw[dashed] (B) -- (D);
    \draw[dashed] (C) -- (D);
    %\draw[dashed] (B) -- (C);
    %\tkzMarkSegment[pos=.5,mark=|](A,(0,4.5,0))
    %\tkzMarkSegment[pos=.5,mark=|](C,(0,4.5,0))
    %\tkzMarkSegment[pos=.5,mark=||](A,(8,0,0))
    %\tkzMarkSegment[pos=.5,mark=||](B,(8,0,0))
    \tkzMarkRightAngle[draw=black,size=0.5](H,E,F)
    \tkzMarkRightAngle[draw=black,size=0.5](C,A,I)
    
    % eye point stuff
    \draw[arw] (E) -- (F) node[anchor=north]{$origin$};
    \draw[arw] (A) -- node[anchor=north west]{$\vec{u}$} (0,0,5);
    %\draw[dotted] (A) -- (F);
    %\draw[dotted] (B) -- (F);
    %\draw[dotted] (C) -- (F);
    %\draw[dotted] (D) -- (F);
    \draw[dotted] (H) -- (F);
%    \tdplotdrawarc[->]{}{2}{0}{90}{}{}
    \pic [draw, -, "$\theta$", angle eccentricity=1.5] {angle = E--F--H};
  \end{tikzpicture}
  
  %\[p_3 = \frac{p_1 + p_2}{2}\]
  %\[\vec{v} = \frac{\vec{u}}{\lvert\lvert\vec{u}\rvert\rvert}\cdot\frac{\frac{\lvert\lvert\overrightarrow{p_0p_2}\rvert\rvert}{2}}{\tan\left(\frac{fov}{2}\right)}\]
  %\[i=\frac{p_1 + p_2}{2} + \vec{v}\]
  \begin{align}
  \theta& = \frac{vertical\ field\ of\ view}{2} \nonumber \\
  \vec{u}& = \overrightarrow{p_0p_1}\times\overrightarrow{p_0p_2} \nonumber \\
  origin& = \frac{p_1 + p_2}{2} + \frac{\vec{u}}{\lvert\lvert\vec{u}\rvert\rvert}\cdot\frac{\frac{\lvert\lvert\overrightarrow{p_0p_2}\rvert\rvert}{2}}{\tan\left(\theta\right)} \label{eq:1}
  \end{align}
  \caption{Viewport and ray origin calculations}
\end{figure}

\tikzstyle{dll}=[draw,rectangle,text width=2cm,text centered,node distance=4cm]
\tikzstyle{java}=[draw,rectangle,inner sep=0.3cm,rounded corners]
\begin{figure}
  \begin{tikzpicture}[auto]
    % loader.dll
    \node[dll] (loader_dll) {loader.dll};
    % raytracer.dll
    \node[dll,right of=loader_dll] (raytracer_dll) {raytracer.dll};
    % raytracer container
    \node[java,fit=(loader_dll)] (container) {};
    % raytracer.class label
    \node at (container.north)[above](raytracer){Raytracer.class};
    % mcraytracer container
    \node[java,fit=(container)(raytracer)](minecraft){};
    % mcraytracer label
    \node at (minecraft.north)[above](jar){mcraytracer.jar};
    % minecraft jar
    \node[dll,left of=raytracer](minecraft_jar){minecraft.jar};
    % java container
    \node[java,fit=(jar)(minecraft)(minecraft_jar)](java){};
    % vm label
    \node at (java.north)[above](vm_label){Java Virtual Machine};
    
    \draw [->] (loader_dll) -- node {} (raytracer_dll);
    \draw [<->] (minecraft_jar) -- node {} (minecraft);
  \end{tikzpicture}
  \centering
  \caption[Binary interaction]{Interaction diagram of the different binaries.}
\end{figure}

% TODO: Java class diagrams(minecraft, raytracer)

\end{document}
