%\documentclass[]{scrartcl}
\documentclass[]{article}
% sans-serif font
\renewcommand{\familydefault}{\sfdefault}

% Bibtex citations
%\usepackage{cite}
% sequence diagrams
\usepackage{pgf-umlsd}
% one inch margins
\usepackage[a4paper, margin=1in]{geometry}
% url referencing
\usepackage{url}
% show reference and figure lists in table of contents
\usepackage[nottoc,numbib]{tocbibind}
% add number to list of figures in table of contents
\renewcommand{\listoffigures}{\begingroup
\tocsection
\tocfile{\listfigurename}{lof}
\endgroup}

\usepackage{tikz,tkz-euclide}
% tikz features
\usetikzlibrary{decorations.pathreplacing,angles,quotes,shapes,arrows,fit}
\usetikzlibrary{calc} % coordinates
\usetikzlibrary{arrows.meta} % better arrows
\usetkzobj{all}

% set default arrow
\tikzset{>=Latex}

% define arrow style
\tikzstyle{arw}=[-{Latex[length=3mm]}]

% extra math
\usepackage{mathtools}

\title{Minecraft: Ray Traced}
%\subtitle{Or: A dynamic acceleration structure for voxel worlds}
\author{Marco Jonkers}

\begin{document}

%\maketitle

\begin{titlepage}
  \centering
  \includegraphics[scale=0.5]{eng_logofc_uas.jpg}\par\vspace{1cm}
  {\scshape\LARGE NHTV Breda University of Applied Sciences\par}
  \vspace{1cm}
  {\scshape\Large Personal project\par}
  \vspace{1.5cm}
  {\huge\bfseries Minecraft: Ray Traced\par}
  \vspace{2cm}
  {\Large Marco Jonkers\par}
  \vspace{0.5cm}
  {Supervisor: David H{\"o}rchner\par}

  
  \vspace{2cm}
  
  \begin{abstract}
    This project attempts to implement a GPU ray tracer in the video game Minecraft, using CUDA.
    The ray tracing itself is done in CUDA. At first, I attempt to ray trace the vertex buffers given by Minecraft. Then, I implement my own data structures for increased performance.
  \end{abstract}
  
  \vfill
  
  % Bottom of the page
  {\large \today\par}
\end{titlepage}

% TODO: Do I want to keep the list of figures?

\newpage
\tableofcontents
\newpage

\section{Minecraft}
Minecraft is a 2011 first-person sandbox video game.
Originally created by Markus "Notch" Persson, it is currently maintained by Mojang.


Minecraft comes in multiple editions, for various platforms. This paper focuses on the PC version of Minecraft, released for Windows, macOS, and Linux.
The PC version is written in Java.

In Minecraft, the game world consists of a three-dimensional grid.
The world is procedurally generated, using a 
mostly comprised of unit blocks, as shown in Figure \ref{fig:ss-worldgen}.

\begin{figure}
  \includegraphics[width=\textwidth]{ss-worldgen.png}
  \centering
  \caption{In-game screenshot of Minecraft, without heads-up display (HUD) or viewmodel.}
  \label{fig:ss-worldgen}
\end{figure}

\section{Minecraft Renderer}
Minecraft uses multi-threaded chunk generation.
Minecraft uses OpenGL.
Minecraft has two options for rendering static geometry:
\begin{description}
  \item[Display Lists] An OpenGL 1.0 core function.
    Display Lists are a group of OpenGL commands that have been compiled and sent to the GPU.
    An object can then be drawn by calling the list.
    The list can be reused, which means you do not have to send the data over again.
  \item[Vertex Buffer Objects] Vertex Buffer Objects ("VBOs") were available in OpenGL 1.4 through an extension, and were later added to the core specification in version 2.1.
    This feature allows you to have a buffer with vertex information, and telling the driver where and how the attributes are stored in the buffer.
\end{description}
My project makes use of Minecraft's VBO rendering, because I can extract the vertex data from the buffers.
\subsection{RenderChunks}
There are four geometry groups:
\begin{description}
  \item[Solid] This is solid geometry.
  \item[Cutout] Used for glass.
  \item[Mipped Cutout] Identical to Cutout, but mipmapped.
  \item[Translucent] Used for block which have partial transparency (alpha blending).
\end{description}
Every geometry group has its own vertex buffer.

\section{Minecraft Forge}
Minecraft Forge ("Forge") is a community created platform for developing and using modifications ("mods") for Minecraft.\footnote{Modification of Minecraft ("modding") is not officially supported by Mojang. For more information, visit \url{https://account.mojang.com/terms}}
\subsection{Setting up a mod development environment}
The Mod Development Kit ("MDK") can be downloaded from the Forge website\footnote{\url{http://files.minecraftforge.net/}}.
The MDK distribution includes ForgeGradle\footnote{\url{https://github.com/MinecraftForge/ForgeGradle}}.
ForgeGradle is a plugin for the Gradle\footnote{\url{https://gradle.org/}} build system.
The Minecraft binaries are downloaded, and subsequently decompiled, deobfuscated, 
The classes are decompiled into srg names.

The Mod Coder Pack\footnote{\url{http://www.modcoderpack.com/website/}} is a package which is used to decompile, change, and recompile Minecraft Java classes.

The Gradle tasks include:
\begin{enumerate}
  \item Download Minecraft .jar files.
  \item Decompile the Minecraft 
  \item Generate the Forge Minecraft binary
\end{enumerate}

Forge explicitly supports the Eclipse and IntelliJ integrated development environments ("IDEs").
I used IntelliJ IDEA Community.
ForgeGradle gives you the option of debugging and building both client and server sides of Minecraft.

\subsection{Changes to Minecraft source code}
Forge adds some new features to the Minecraft source code, in order to support multi-mod functionality.

\subsection{Creating a mod}
In general there are three approaches to creating a mod:
\begin{enumerate}
  \item Build a mod on top of the Forge Minecraft code
  \item Edit the Minecraft source directly
  \item Change the Minecraft bytecode at runtime
\end{enumerate}
For most mods, the first approach is sufficient.
This also enables the developer to freely distribute their mod.
Editing the Minecraft source directly means that the mod cannot be redistributed, because the original Minecraft code is copyrighted.

\section{C++ and CUDA}
I wanted to create a GPU ray tracer.
There are various methods to achieve this. 
I wanted to take advantage of the vertex buffers in CUDA.
Because Minecraft uses OpenGL through the LWJGL\footnote{\url{https://www.lwjgl.org/}} library, I could have chosen to use OpenGL compute shaders.
However, I have no experience with OpenGL compute shaders, whereas I do have experience with NVIDIA CUDA.

There exist Java bindings for CUDA, but using C++ removes my dependency on a binding layer.
\subsection{Java Native Interface}
Java Native Interface ("JNI") is a programming framework that allows for Java code to interact with native code.
\subsection{CUDA/OpenGL interoperability}

\subsection{Creating a Visual Studio project}
For setting up the native part of the mod, I created a Visual Studio CUDA project.

\subsubsection{Reloading C++}
Java IDEs such as IntelliJ support hot-swapping of method bodies by using the HotSwap\texttrademark functionality of the Java Platform Debugger Architecture.
I created something similar for my native code by using a technique called DLL reloading.
Once a native library has been loaded by the JVM, I cannot make changes to it.
Therefore I am using a passthrough DLL, which passes the calls from Java to another DLL.

\subsection{Setting up the Visual Studio debugger}
IntelliJ debug sessions are good for testing if my Java ASM works correctly, and if my JNI bindings are set up properly.
However, if an error occurs a native part, the debug session ends immediately.
The crash output from IntelliJ is unable to use the debug information from Visual Studio.
I wanted to use the Visual Studio debugger for the native part.
Getting that working was quite tricky.
I had to launch java.exe with the right command line arguments and working directory.
I looked at the launch parameters given to java.exe when starting a debug session from IntelliJ.
The Visual Studio debugger can be started by copying the command line arguments from an IntelliJ debug session.


\section{Ray Tracing OpenGL Vertex Buffers}

\subsection{Using events}
I wanted to see if I could make my mod work using the first approach.
Forge adds hooks to the game loop which I could use to intercept the rendering code.

\subsection{Using Java ASM}

Here I explain how the project is set up and the technologies involved.

The Minecraft Forge project allows me to do two things:
  Listen to specific events using pre-installed hooks
  Edit Minecraft bytecode before it is loaded
Using Java Native Interface (JNI), I can call into C++ code from Java.
The C++ code contains the CUDA kernel.
Data is passed between OpenGL and CUDA using CUDA's graphics interop layer.

I am using the Minecraft Forge API.
Forge is built on top of the Mod Coder Pack (MCP).
MCP is a tool for decompiling Minecraft.
A copy of the game is obtained by using the official installer from Mojang.
Forge uses Gradle.
During development, Java loads my classpath directly.
In release mode, my class files would have to be compressed into an archive first.
The path to my DLLs is passed to the virtual machine.
I have shown this in Figure \ref{fig:modules}.

% TODO: fix the minecraft.jar node and add Forge Minecraft
\tikzstyle{dll}=[draw,rectangle,text width=2cm,text centered,node distance=4cm]
\tikzstyle{java}=[draw,rectangle,inner sep=0.3cm,rounded corners]
\begin{figure}
  \begin{tikzpicture}[auto]
  % loader.dll
  \node[dll] (loader_dll) {loader.dll};
  % raytracer.dll
  \node[dll,right of=loader_dll] (raytracer_dll) {raytracer.dll};
  % raytracer container
  \node[java,fit=(loader_dll)] (container) {};
  % raytracer.class label
  \node at (container.north)[above](raytracer){Raytracer.class};
  % mcraytracer container
  \node[java,fit=(container)(raytracer)](minecraft){};
  % mcraytracer label
  \node at (minecraft.north)[above](jar){mcraytracer.jar};
  % minecraft jar
  \node[java,left of=raytracer](minecraft_jar){minecraft.jar};
  % java container
  \node[java,fit=(jar)(minecraft)(minecraft_jar)](java){};
  % vm label
  \node at (java.north)[above](vm_label){Java Virtual Machine};
  
  \draw [->] (loader_dll) -- node {} (raytracer_dll);
  %\draw [<->] (minecraft_jar) -- node {} (minecraft);
  \end{tikzpicture}
  \centering
  \caption[Binary interaction]{Interaction diagram of the different binaries.}
  \label{fig:modules}
\end{figure}

\section{Preprocessing Vertex Buffers}

\subsection{Obtaining the buffers}

\subsection{Acceleration structure}

\section{Future work}
I only got to work on the world rendering of the game.
Viewmodels (player-held items) are not ray traced.
Non-playable characters ("NPCs") are not ray traced.

\bibliography{minecraft_ray_traced}{}
\bibliographystyle{plain}
%\bibliographystyle{apalike}

\listoffigures

% Code flow structure
\begin{figure}
  \centering
  \label{fig:sequence}
  \begin{sequencediagram}
    \newthread{minecraft}{Forge Minecraft}{}
    \newinst[2]{forge}{Forge Mod}{}
    \newinst[2]{loader}{C++/CUDA}{}
    \begin{call}{minecraft}{transform()}{forge}{}
    \end{call}
    \postlevel
    \begin{call}{minecraft}{Raytracer()}{forge}{}
      \begin{call}{forge}{init()}{loader}{}
      \end{call}
    \end{call}
    %    \postlevel
    %    \begin{call}{minecraft}{onPreInitGuiEvent()}{forge}{}
    %      \begin{call}{forge}{resize()}{loader}{}
    %      \end{call}
    %    \end{call}
    \begin{sdblock}{Main Loop}{}
      \begin{call}{minecraft}{initialize()}{forge}{}
        \begin{call}{forge}{setViewEntity()}{loader}{}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{addRenderChunk()}{forge}{}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderChunkLayer()}{forge}{}
        \begin{call}{forge}{setVertexBuffer()}{loader}{}
          \begin{call}{loader}{GetIntField()}{loader}{glBufferId}
          \end{call}
        \end{call}
      \end{call}
      \postlevel
      \begin{call}{minecraft}{renderWorld()}{forge}{}
        \begin{call}{forge}{setViewingPlane()}{loader}{}
        \end{call}
        \postlevel
        \begin{call}{forge}{raytrace()}{loader}{texture ID}
          \begin{call}{loader}{Kernel()}{loader}{}
          \end{call}
        \end{call}
      \end{call}
    \end{sdblock}
  \end{sequencediagram}
  \caption[Sequence diagram]{Sequence diagram showing interaction between the modules}
\end{figure}

% hfov = 102.4478577779882556443232935315
% ++(141.22392888899412782216164676575:6cm);
% ++(38.77607111100587217783835323425:6cm);

\begin{figure}
  \centering
  \begin{tikzpicture}
  \draw[step=0.5cm,very thin,opacity=0.2] (-6,-6) grid (6.5,6.5);
  %\fill (0,0) -- (0.5,0) -- (0.5,0.5) -- (0,0.5) -- (0,0);
  \draw[dashed] (-6,0) -- (6.5,0);
  \draw[dashed] (-6,0.5) -- (6.5,0.5);
  \draw[dashed] (0,-6) -- (0,6.5);
  \draw[dashed] (0.5,-6) -- (0.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0.5,0.5) -- node[above=15pt] {12} (6.5,0.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0.5) -- node[left=15pt] {12} (0,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,6.5) -- node[above=15pt] {35} (6.5,6.5);
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (-6,-6) -- node[left=15pt] {35} (-6,6.5);
  \draw[fill] (0.25,0.25) circle (.5ex);
  
  % view frustum
  \draw (0.25,0.25) -- (-6,5.25);
  \draw (0.25,0.25) -- (6.5,5.25);
  \fill[color=gray,opacity=0.3] (-6,6.5) -- (-6,5.25) -- (0.25,0.25) -- (6.5,5.25) -- (6.5,6.5);
  
  %\draw[decoration={brace,mirror,raise=5pt},decorate] (0.5,0) -- node[below=6pt] {Render distance} (6.5,0);
  \end{tikzpicture}
  \caption[Top-down view of vertex buffer array]{
    A top-down view of the vertex buffer array, assuming a render distance of 12.
    The player's view cone is shown facing north.
    Each cell contains 16 RenderChunks.
    When the player crosses a horizontal chunk boundary, every buffer in the grid is move once space.
  }
\end{figure}

\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.3]
  \foreach \x in{0,...,16} {
    \draw[very thin] (0,\x ,16) -- (16,\x ,16);
    \draw[very thin] (\x ,0,16) -- (\x ,16,16);
    \draw[very thin] (16,\x ,16) -- (16,\x ,0);
    \draw[very thin] (\x ,16,16) -- (\x ,16,0);
    \draw[very thin] (16,0,\x ) -- (16,16,\x );
    \draw[very thin] (0,16,\x ) -- (16,16,\x );
  }
  % right
  \draw[dashed] (16,0,0) -- ++(5,0,0);
  \draw[dashed] (16,16,0) -- ++(5,0,0);
  \draw[dashed] (16,16,16) -- ++(5,0,0);
  \draw[dashed] (16,0,16) -- ++(5,0,0);
  % top
  \draw[dashed] (0,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,0) -- ++(0,5,0);
  \draw[dashed] (16,16,16) -- ++(0,5,0);
  \draw[dashed] (0,16,16) -- ++(0,5,0);
  % back
  \draw[dashed] (0,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,16,0) -- ++(0,0,-5);
  \draw[dashed] (16,0,0) -- ++(0,0,-5);
  % front
  \draw[dashed] (0,16,16) -- ++(0,0,5);
  \draw[dashed] (16,16,16) -- ++(0,0,5);
  \draw[dashed] (16,0,16) -- ++(0,0,5);
  \draw[dashed] (0,0,16) -- ++(0,0,5);
  % left
  \draw[dashed] (0,0,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,16) -- ++(-5,0,0);
  \draw[dashed] (0,16,0) -- ++(-5,0,0);
  % bottom
  \draw[dashed] (16,0,0) -- ++(0,-5,0);
  \draw[dashed] (16,0,16) -- ++(0,-5,0);
  \draw[dashed] (0,0,16) -- ++(0,-5,0);
  % curly braces
  \draw[decoration={brace,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[left=15pt]{16} (0,16,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (0,0,16) -- node[below=15pt]{16} (16,0,16);
  \draw[decoration={brace,mirror,amplitude=10pt,raise=5pt},decorate] (16,0,16) -- node[below=15pt,right=10pt]{16} (16,0,0);
  \end{tikzpicture}
  \caption[Diagram of a RenderChunk]{A single, completely filled RenderChunk.}
\end{figure}

% TODO Rotate this diagram 90 degrees along Y axis
\begin{figure}
  \centering
  \begin{tikzpicture}[scale=0.5]
    \coordinate (A) at (0,0,0);
    \coordinate (B) at (16,0,0);
    \coordinate (C) at (0,9,0);
    \coordinate (D) at (16,9,0);
    \coordinate (E) at (8,4.5,0);
    \coordinate (F) at (8,4.5,16);
    \coordinate (G) at (0,4.5,0);
    \coordinate (H) at (8,9,0);
    \coordinate (I) at (0,0,5);
    \draw[arw] (A) node[anchor=north]{$p_0$} -- (B) node[anchor=north]{$p_1$};
    \draw[arw] (A) -- (C) node[anchor=south]{$p_2$};
    %\draw[arw] (A) -- (8,4.5) node[anchor=west]{$p_3$};
    \draw[dashed] (8,9,0) -- (E);
    %\draw[dashed] (8,0,0) -- (E);
    \draw[dashed] (B) -- (D);
    \draw[dashed] (C) -- (D);
    %\draw[dashed] (B) -- (C);
    %\tkzMarkSegment[pos=.5,mark=|](A,(0,4.5,0))
    %\tkzMarkSegment[pos=.5,mark=|](C,(0,4.5,0))
    %\tkzMarkSegment[pos=.5,mark=||](A,(8,0,0))
    %\tkzMarkSegment[pos=.5,mark=||](B,(8,0,0))
    \tkzMarkRightAngle[draw=black,size=0.5](H,E,F)
    \tkzMarkRightAngle[draw=black,size=0.5](C,A,I)
    
    % eye point stuff
    \draw[arw] (E) -- (F) node[anchor=north]{$origin$};
    \draw[arw] (A) -- node[anchor=north west]{$\vec{u}$} (0,0,5);
    %\draw[dotted] (A) -- (F);
    %\draw[dotted] (B) -- (F);
    %\draw[dotted] (C) -- (F);
    %\draw[dotted] (D) -- (F);
    \draw[dotted] (H) -- (F);
%    \tdplotdrawarc[->]{}{2}{0}{90}{}{}
    \pic [draw, -, "$\theta$", angle eccentricity=1.5] {angle = E--F--H};
  \end{tikzpicture}
  
  %\[p_3 = \frac{p_1 + p_2}{2}\]
  %\[\vec{v} = \frac{\vec{u}}{\lvert\lvert\vec{u}\rvert\rvert}\cdot\frac{\frac{\lvert\lvert\overrightarrow{p_0p_2}\rvert\rvert}{2}}{\tan\left(\frac{fov}{2}\right)}\]
  %\[i=\frac{p_1 + p_2}{2} + \vec{v}\]
  \begin{align}
  \theta& = \frac{vertical\ field\ of\ view}{2} \nonumber \\
  \vec{u}& = \overrightarrow{p_0p_1}\times\overrightarrow{p_0p_2} \nonumber \\
  origin& = \frac{p_1 + p_2}{2} + \frac{\vec{u}}{\lvert\lvert\vec{u}\rvert\rvert}\cdot\frac{\frac{\lvert\lvert\overrightarrow{p_0p_2}\rvert\rvert}{2}}{\tan\left(\theta\right)} \label{eq:1}
  \end{align}
  \caption{Viewport and ray origin calculations}
\end{figure}

% TODO: Java class diagrams(minecraft, raytracer)

\end{document}
